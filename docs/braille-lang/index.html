<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‚°Ç‚°≤‚°°‚°©‚°¨‚°¨‚°• BrailleLang ‚Äî AI-Native Programming in Braille</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600;700&family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #0a0e17;
            --bg-card: #111827;
            --bg-code: #0d1321;
            --border: #1e293b;
            --border-glow: #3b82f680;
            --text: #e2e8f0;
            --text-dim: #94a3b8;
            --text-bright: #f8fafc;
            --accent: #3b82f6;
            --accent-glow: #3b82f640;
            --green: #22c55e;
            --green-dim: #22c55e40;
            --purple: #a78bfa;
            --purple-dim: #a78bfa40;
            --orange: #f97316;
            --orange-dim: #f9731640;
            --pink: #ec4899;
            --red: #ef4444;
            --cyan: #06b6d4;
            --yellow: #eab308;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Inter', -apple-system, sans-serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.6;
            overflow-x: hidden;
        }

        /* ‚îÄ‚îÄ Hero ‚îÄ‚îÄ */
        .hero {
            position: relative;
            padding: 80px 20px 60px;
            text-align: center;
            overflow: hidden;
        }
        .hero::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(ellipse at 50% 0%, var(--accent-glow) 0%, transparent 50%),
                        radial-gradient(ellipse at 20% 50%, var(--purple-dim) 0%, transparent 40%),
                        radial-gradient(ellipse at 80% 50%, var(--green-dim) 0%, transparent 40%);
            animation: heroGlow 8s ease-in-out infinite alternate;
            z-index: 0;
        }
        @keyframes heroGlow {
            0% { transform: translate(0, 0) scale(1); }
            100% { transform: translate(-2%, -3%) scale(1.05); }
        }
        .hero > * { position: relative; z-index: 1; }
        .hero h1 {
            font-size: 3.5rem;
            font-weight: 800;
            letter-spacing: -0.02em;
            margin-bottom: 8px;
            background: linear-gradient(135deg, var(--text-bright), var(--accent), var(--purple));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .hero .braille-title {
            font-family: 'JetBrains Mono', monospace;
            font-size: 2rem;
            color: var(--accent);
            margin-bottom: 16px;
            letter-spacing: 0.15em;
            text-shadow: 0 0 30px var(--accent-glow);
        }
        .hero p {
            font-size: 1.15rem;
            color: var(--text-dim);
            max-width: 640px;
            margin: 0 auto 32px;
        }
        .hero-badges {
            display: flex;
            gap: 12px;
            justify-content: center;
            flex-wrap: wrap;
        }
        .badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 14px;
            border-radius: 999px;
            font-size: 0.8rem;
            font-weight: 600;
            border: 1px solid var(--border);
            background: var(--bg-card);
        }
        .badge.ai { border-color: var(--purple); color: var(--purple); }
        .badge.braille { border-color: var(--accent); color: var(--accent); }
        .badge.open { border-color: var(--green); color: var(--green); }

        /* ‚îÄ‚îÄ Container ‚îÄ‚îÄ */
        .container {
            max-width: 1100px;
            margin: 0 auto;
            padding: 0 20px;
        }

        /* ‚îÄ‚îÄ Sections ‚îÄ‚îÄ */
        section {
            padding: 60px 0;
        }
        section h2 {
            font-size: 1.8rem;
            font-weight: 700;
            margin-bottom: 8px;
            color: var(--text-bright);
        }
        section .subtitle {
            color: var(--text-dim);
            margin-bottom: 32px;
            font-size: 1rem;
        }

        /* ‚îÄ‚îÄ Concept Grid ‚îÄ‚îÄ */
        .concept-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
            gap: 12px;
            margin-top: 24px;
        }
        .concept-card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 16px;
            transition: all 0.2s;
        }
        .concept-card:hover {
            border-color: var(--accent);
            box-shadow: 0 0 20px var(--accent-glow);
            transform: translateY(-2px);
        }
        .concept-card .braille-char {
            font-size: 2rem;
            font-family: 'JetBrains Mono', monospace;
            margin-bottom: 4px;
        }
        .concept-card .concept-name {
            font-weight: 600;
            font-size: 0.85rem;
            color: var(--purple);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .concept-card .prog-role {
            font-size: 0.8rem;
            color: var(--text-dim);
            margin-top: 2px;
        }
        .concept-card .js-equiv {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            color: var(--green);
            margin-top: 4px;
        }

        /* ‚îÄ‚îÄ Playground ‚îÄ‚îÄ */
        .playground {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 16px;
            overflow: hidden;
        }
        .playground-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 20px;
            border-bottom: 1px solid var(--border);
            background: var(--bg-code);
        }
        .playground-header h3 {
            font-size: 0.9rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .playground-tabs {
            display: flex;
            gap: 4px;
        }
        .playground-tab {
            padding: 6px 14px;
            border-radius: 8px;
            font-size: 0.78rem;
            font-weight: 500;
            cursor: pointer;
            border: 1px solid transparent;
            background: transparent;
            color: var(--text-dim);
            transition: all 0.15s;
        }
        .playground-tab:hover { color: var(--text); background: var(--border); }
        .playground-tab.active {
            color: var(--accent);
            background: var(--accent-glow);
            border-color: var(--accent);
        }
        .playground-body {
            display: flex;
            min-height: 340px;
        }
        @media (max-width: 768px) {
            .playground-body { flex-direction: column; }
        }
        .editor-pane, .output-pane {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        .editor-pane {
            border-right: 1px solid var(--border);
        }
        @media (max-width: 768px) {
            .editor-pane { border-right: none; border-bottom: 1px solid var(--border); }
        }
        .pane-label {
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-dim);
            padding: 8px 16px 4px;
        }
        #editor {
            flex: 1;
            width: 100%;
            min-height: 280px;
            padding: 8px 16px;
            background: transparent;
            color: var(--text-bright);
            border: none;
            outline: none;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            line-height: 1.8;
            resize: none;
            tab-size: 2;
        }
        #output {
            flex: 1;
            padding: 8px 16px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            line-height: 1.7;
            white-space: pre-wrap;
            overflow-y: auto;
            color: var(--green);
            min-height: 280px;
        }
        #output .error { color: var(--red); }
        #output .info { color: var(--text-dim); }
        #output .ai { color: var(--purple); }

        .playground-footer {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            padding: 10px 16px;
            border-top: 1px solid var(--border);
            background: var(--bg-code);
            flex-wrap: wrap;
        }
        .btn {
            padding: 8px 20px;
            border-radius: 8px;
            font-size: 0.82rem;
            font-weight: 600;
            cursor: pointer;
            border: 1px solid var(--border);
            transition: all 0.15s;
            font-family: 'Inter', sans-serif;
        }
        .btn-primary {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
        }
        .btn-primary:hover {
            background: #2563eb;
            box-shadow: 0 0 20px var(--accent-glow);
        }
        .btn-secondary {
            background: var(--bg-card);
            color: var(--text);
        }
        .btn-secondary:hover { border-color: var(--text-dim); }
        .btn-group { display: flex; gap: 8px; flex-wrap: wrap; }
        .stats {
            font-size: 0.75rem;
            color: var(--text-dim);
            font-family: 'JetBrains Mono', monospace;
        }

        /* ‚îÄ‚îÄ Examples ‚îÄ‚îÄ */
        .example-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 16px;
            margin-top: 24px;
        }
        .example-card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 12px;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.2s;
        }
        .example-card:hover {
            border-color: var(--accent);
            box-shadow: 0 0 20px var(--accent-glow);
        }
        .example-card .example-title {
            padding: 14px 16px 8px;
            font-weight: 600;
            font-size: 0.95rem;
            color: var(--text-bright);
        }
        .example-card .example-desc {
            padding: 0 16px 8px;
            font-size: 0.8rem;
            color: var(--text-dim);
        }
        .example-card pre {
            padding: 10px 16px 14px;
            background: var(--bg-code);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.78rem;
            line-height: 1.7;
            color: var(--cyan);
            overflow-x: auto;
            border-top: 1px solid var(--border);
        }

        /* ‚îÄ‚îÄ Reference Table ‚îÄ‚îÄ */
        .ref-section { margin-top: 32px; }
        .ref-section h3 {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 12px;
            color: var(--text-bright);
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 24px;
        }
        th, td {
            text-align: left;
            padding: 10px 14px;
            border-bottom: 1px solid var(--border);
            font-size: 0.85rem;
        }
        th {
            color: var(--text-dim);
            font-weight: 600;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
        }
        td:first-child {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.3rem;
            color: var(--accent);
        }
        td:nth-child(3) {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            color: var(--green);
        }

        /* ‚îÄ‚îÄ Encoder ‚îÄ‚îÄ */
        .encoder-row {
            display: flex;
            gap: 16px;
            margin-top: 16px;
            align-items: stretch;
        }
        @media (max-width: 600px) {
            .encoder-row { flex-direction: column; }
        }
        .encoder-box {
            flex: 1;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 16px;
        }
        .encoder-box label {
            display: block;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-dim);
            margin-bottom: 8px;
        }
        .encoder-box textarea {
            width: 100%;
            min-height: 80px;
            background: var(--bg-code);
            color: var(--text-bright);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 10px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            resize: vertical;
            outline: none;
        }
        .encoder-box textarea:focus { border-color: var(--accent); }

        /* ‚îÄ‚îÄ Architecture ‚îÄ‚îÄ */
        .arch-flow {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            flex-wrap: wrap;
            margin: 24px 0;
        }
        .arch-node {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 12px 20px;
            font-size: 0.85rem;
            font-weight: 600;
            text-align: center;
        }
        .arch-node .mono {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            color: var(--text-dim);
            margin-top: 2px;
        }
        .arch-arrow {
            font-size: 1.2rem;
            color: var(--accent);
        }

        /* ‚îÄ‚îÄ Footer ‚îÄ‚îÄ */
        footer {
            text-align: center;
            padding: 40px 20px;
            border-top: 1px solid var(--border);
            color: var(--text-dim);
            font-size: 0.85rem;
        }
        footer a { color: var(--accent); text-decoration: none; }
        footer a:hover { text-decoration: underline; }

        /* ‚îÄ‚îÄ SAL Chat ‚îÄ‚îÄ */
        .sal-chat {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 16px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 600px;
        }
        .sal-chat-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 14px 20px;
            border-bottom: 1px solid var(--border);
            background: var(--bg-code);
        }
        .sal-chat-header h3 { font-size: 0.95rem; font-weight: 700; display: flex; align-items: center; gap: 8px; }
        .sal-chat-header .sal-status { font-size: 0.7rem; color: var(--green); font-weight: 500; }
        .sal-chat-header .sal-status.offline { color: var(--red); }
        .sal-messages {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        .sal-msg {
            max-width: 85%;
            padding: 12px 16px;
            border-radius: 12px;
            font-size: 0.88rem;
            line-height: 1.6;
            white-space: pre-wrap;
            word-break: break-word;
        }
        .sal-msg.sal {
            align-self: flex-start;
            background: linear-gradient(135deg, #1e293b, #0f172a);
            border: 1px solid var(--border);
            color: var(--text);
        }
        .sal-msg.sal .sal-name { color: var(--accent); font-weight: 700; font-size: 0.75rem; margin-bottom: 4px; display: block; }
        .sal-msg.user {
            align-self: flex-end;
            background: var(--accent);
            color: white;
            border: 1px solid transparent;
        }
        .sal-msg .br-code {
            display: block;
            margin: 8px 0;
            padding: 10px 12px;
            background: var(--bg-code);
            border: 1px solid var(--border);
            border-radius: 8px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.82rem;
            color: var(--cyan);
            cursor: pointer;
            transition: border-color 0.2s;
            position: relative;
        }
        .sal-msg .br-code:hover { border-color: var(--accent); }
        .sal-msg .br-code::after {
            content: '‚†∑ Load into playground';
            position: absolute;
            top: 4px;
            right: 8px;
            font-size: 0.65rem;
            color: var(--text-dim);
            font-family: 'Inter', sans-serif;
        }
        .sal-msg .br-code:hover::after { color: var(--accent); }
        .sal-chat-input {
            display: flex;
            gap: 8px;
            padding: 12px 16px;
            border-top: 1px solid var(--border);
            background: var(--bg-code);
        }
        .sal-chat-input input {
            flex: 1;
            padding: 10px 14px;
            border-radius: 10px;
            border: 1px solid var(--border);
            background: var(--bg-card);
            color: var(--text-bright);
            font-family: 'Inter', sans-serif;
            font-size: 0.88rem;
            outline: none;
        }
        .sal-chat-input input:focus { border-color: var(--accent); }
        .sal-chat-input input::placeholder { color: var(--text-dim); }
        .sal-chat-input button {
            padding: 10px 20px;
            border-radius: 10px;
            border: none;
            background: var(--accent);
            color: white;
            font-weight: 600;
            font-size: 0.85rem;
            cursor: pointer;
            transition: background 0.15s;
            font-family: 'Inter', sans-serif;
        }
        .sal-chat-input button:hover { background: #2563eb; }
        .sal-chat-input button:disabled { opacity: 0.5; cursor: not-allowed; }
        .sal-key-banner {
            padding: 12px 16px;
            background: var(--orange-dim);
            border-bottom: 1px solid var(--orange);
            font-size: 0.82rem;
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }
        .sal-key-banner input {
            flex: 1;
            min-width: 200px;
            padding: 6px 10px;
            border-radius: 6px;
            border: 1px solid var(--orange);
            background: var(--bg-code);
            color: var(--text-bright);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.78rem;
            outline: none;
        }
        .sal-key-banner button {
            padding: 6px 14px;
            border-radius: 6px;
            border: none;
            background: var(--orange);
            color: white;
            font-weight: 600;
            font-size: 0.78rem;
            cursor: pointer;
        }
        .sal-typing { color: var(--text-dim); font-style: italic; font-size: 0.82rem; padding: 8px 16px; }

        /* ‚îÄ‚îÄ Scrollbar ‚îÄ‚îÄ */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: var(--bg); }
        ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--text-dim); }
    </style>
</head>
<body>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê HERO ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<div class="hero">
    <div class="braille-title">‚°Ç‚°≤‚°°‚°©‚°¨‚°¨‚°•</div>
    <h1>BrailleLang</h1>
    <p>An AI-native programming language encoded entirely in Unicode Braille (U+2800‚ÄìU+28FF). Every keyword is a concept. Every program is tactile.</p>
    <div class="hero-badges">
        <span class="badge braille">‚†† AI-Native Primitives</span>
        <span class="badge ai">‚£† 256 Braille Patterns</span>
        <span class="badge open">‚†É Open Source</span>
    </div>
</div>

<div class="container">

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê PLAYGROUND ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<section id="playground">
    <h2>‚†∏ Playground</h2>
    <p class="subtitle">Write and run BrailleLang code directly in your browser.</p>
    <div class="playground">
        <div class="playground-header">
            <h3>‚†∞ Editor</h3>
            <div class="playground-tabs">
                <button class="playground-tab active" data-view="run">Run</button>
                <button class="playground-tab" data-view="tokens">Tokens</button>
                <button class="playground-tab" data-view="ast">AST</button>
                <button class="playground-tab" data-view="js">‚Üí JS</button>
                <button class="playground-tab" data-view="sal">‚£† SAL</button>
            </div>
        </div>
        <div class="playground-body">
            <div class="editor-pane">
                <div class="pane-label">Source (.br)</div>
                <textarea id="editor" spellcheck="false">‚£Ä Hello World in BrailleLang ‚£Ä

‚†∞ ‚†£ ‚†∂‚°à‚°•‚°¨‚°¨‚°Ø‚††‚°∑‚°Ø‚°≤‚°¨‚°§‚†∂ ‚†ú ‚†Ü

‚†Å ‚°Æ‚°°‚°≠‚°• ‚†™ ‚†∂‚°Ç‚°≤‚°°‚°©‚°¨‚°¨‚°•‚°å‚°°‚°Æ‚°ß‚†∂ ‚†Ü
‚†∞ ‚†£ ‚†∂‚°à‚°•‚°¨‚°¨‚°Ø‚††‚°¶‚°≤‚°Ø‚°≠‚††‚†∂ ‚†Ç ‚°Æ‚°°‚°≠‚°• ‚†ú ‚†Ü

‚£ø</textarea>
            </div>
            <div class="output-pane">
                <div class="pane-label">Output</div>
                <div id="output"><span class="info">Press ‚ñ∂ Run to execute...</span></div>
            </div>
        </div>
        <div class="playground-footer">
            <div class="btn-group">
                <button class="btn btn-primary" id="btn-run">‚ñ∂ Run</button>
                <button class="btn btn-secondary" id="btn-clear">Clear</button>
                <select id="edge-mode" style="padding:6px 10px;border-radius:8px;border:1px solid var(--border);background:var(--bg-card);color:var(--text);font-size:0.78rem;font-family:'JetBrains Mono',monospace;cursor:pointer;outline:none;">
                    <option value="dry_run">‚†Ä dry-run</option>
                    <option value="cache_only">‚†Å cache-only</option>
                    <option value="local">‚†† local (WebLLM)</option>
                    <option value="hybrid">‚°™ hybrid</option>
                    <option value="cloud">‚†≥ cloud</option>
                </select>
            </div>
            <div class="stats" id="stats"><span id="edge-status" style="color:var(--text-dim)"></span></div>
        </div>
    </div>
</section>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê EXAMPLES ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<section id="examples">
    <h2>‚†∑ Examples</h2>
    <p class="subtitle">Click an example to load it into the playground.</p>
    <div class="example-grid">
        <div class="example-card" data-example="hello">
            <div class="example-title">Hello World</div>
            <div class="example-desc">Print a greeting and use variables</div>
            <pre>‚†∞ ‚†£ ‚†∂‚°à‚°•‚°¨‚°¨‚°Ø‚††‚°∑‚°Ø‚°≤‚°¨‚°§‚†∂ ‚†ú ‚†Ü
‚†Å ‚°Æ‚°°‚°≠‚°• ‚†™ ‚†∂‚°Ç‚°≤‚°°‚°©‚°¨‚°¨‚°•‚°å‚°°‚°Æ‚°ß‚†∂ ‚†Ü
‚†∞ ‚†£ ‚°Æ‚°°‚°≠‚°• ‚†ú ‚†Ü</pre>
        </div>
        <div class="example-card" data-example="fibonacci">
            <div class="example-title">Fibonacci</div>
            <div class="example-desc">Recursive function with loops</div>
            <pre>‚†É ‚°¶‚°©‚°¢ ‚†£ ‚†ê‚°Æ ‚†ú ‚†≥
  ‚†° ‚†£ ‚†ê‚°Æ ‚†ï ‚†º‚†É ‚†ú ‚†≥ ‚°Å ‚†ê‚°Æ ‚†Ü ‚†æ
  ‚°† ‚†≥ ‚°Å ‚°¶‚°©‚°¢ ‚†£ ‚†ê‚°Æ ‚†§ ‚†º‚†Å ‚†ú
    ‚†Æ ‚°¶‚°©‚°¢ ‚†£ ‚†ê‚°Æ ‚†§ ‚†º‚†É ‚†ú ‚†Ü ‚†æ
‚†æ</pre>
        </div>
        <div class="example-card" data-example="ai-infer">
            <div class="example-title">AI Inference</div>
            <div class="example-desc">Call an LLM with ‚†† (MIND)</div>
            <pre>‚†Å ‚°≤‚°•‚°≥‚°µ‚°¨‚°¥ ‚†™ ‚†† ‚†£ ‚†∂‚°∑‚°®‚°°‚°¥‚††‚°©‚°≥‚††‚°Ç‚°≤‚°°‚°©‚°¨‚°¨‚°•‚†∂ ‚†ú ‚†Ü
‚†∞ ‚†£ ‚°≤‚°•‚°≥‚°µ‚°¨‚°¥ ‚†ú ‚†Ü</pre>
        </div>
        <div class="example-card" data-example="arithmetic">
            <div class="example-title">Arithmetic</div>
            <div class="example-desc">Math operators and expressions</div>
            <pre>‚†Å ‚†ê‚°° ‚†™ ‚†º‚†Å‚†ö ‚†Ü
‚†Å ‚†ê‚°¢ ‚†™ ‚†º‚†É‚†ö ‚†Ü
‚†∞ ‚†£ ‚†ê‚°° ‚†Æ ‚†ê‚°¢ ‚†ú ‚†Ü
‚†∞ ‚†£ ‚†ê‚°° ‚†¶ ‚†ê‚°¢ ‚†ú ‚†Ü</pre>
        </div>
        <div class="example-card" data-example="control-flow">
            <div class="example-title">Control Flow</div>
            <div class="example-desc">If/else with TRUTH and WISDOM</div>
            <pre>‚†Å ‚†ê‚°∏ ‚†™ ‚†º‚†Å‚†ö ‚†Ü
‚†° ‚†£ ‚†ê‚°∏ ‚†≤ ‚†º‚†ë ‚†ú ‚†≥
  ‚†∞ ‚†£ ‚†∂‚°¨‚°°‚°≤‚°ß‚°•‚†∂ ‚†ú ‚†Ü
‚†æ ‚°† ‚†≥
  ‚†∞ ‚†£ ‚†∂‚°≥‚°≠‚°°‚°¨‚°¨‚†∂ ‚†ú ‚†Ü
‚†æ</pre>
        </div>
        <div class="example-card" data-example="embed">
            <div class="example-title">AI Embeddings</div>
            <div class="example-desc">Get vector embeddings with ‚†´ (TECHNOLOGY)</div>
            <pre>‚†Å ‚°∂‚°•‚°£ ‚†™ ‚†´ ‚†£ ‚†∂‚°¢‚°≤‚°°‚°©‚°¨‚°¨‚°•‚†∂ ‚†ú ‚†Ü
‚†∞ ‚†£ ‚†∂‚°Ö‚°≠‚°¢‚°•‚°§‚°§‚°©‚°Æ‚°ß‚†ä‚†∂ ‚†Ç ‚°∂‚°•‚°£ ‚†ú ‚†Ü</pre>
        </div>
    </div>
</section>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê ENCODER ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<section id="encoder">
    <h2>‚†ø Encoder / Decoder</h2>
    <p class="subtitle">Translate between ASCII and Braille Unicode.</p>
    <div class="encoder-row">
        <div class="encoder-box">
            <label>ASCII Text</label>
            <textarea id="ascii-input" placeholder="Type ASCII here...">Hello World</textarea>
        </div>
        <div class="encoder-box">
            <label>Braille (U+2800‚ÄìU+28FF)</label>
            <textarea id="braille-output" placeholder="Braille appears here..." readonly></textarea>
        </div>
    </div>
</section>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê CONCEPT MAP ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<section id="concepts">
    <h2>‚£† Concept ‚Üí Keyword Map</h2>
    <p class="subtitle">Every keyword's Braille pattern reflects its semantic meaning from the BrailleConceptAtlas.</p>
    <div class="concept-grid" id="concept-grid"></div>
</section>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê REFERENCE ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<section id="reference">
    <h2>‚†∑ Language Reference</h2>

    <div class="ref-section">
        <h3>Operators</h3>
        <table>
            <thead><tr><th>Braille</th><th>Operation</th><th>Symbol</th><th>Concept</th></tr></thead>
            <tbody id="op-table"></tbody>
        </table>
    </div>

    <div class="ref-section">
        <h3>Delimiters</h3>
        <table>
            <thead><tr><th>Braille</th><th>Name</th><th>Symbol</th><th>Concept</th></tr></thead>
            <tbody id="delim-table"></tbody>
        </table>
    </div>

    <div class="ref-section">
        <h3>Identifier Prefix <code style="color:var(--accent)">‚†ê</code></h3>
        <p style="color:var(--text-dim);margin-bottom:12px;">Single-character variable names that collide with keywords must be prefixed with <code style="color:var(--accent)">‚†ê</code>. Multi-character names that form a unique braille word don't need it.</p>
    </div>
</section>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê ARCHITECTURE ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<section id="architecture">
    <h2>‚†´ Architecture</h2>
    <p class="subtitle">How BrailleLang source becomes execution.</p>
    <div class="arch-flow">
        <div class="arch-node">üìÑ Source<div class="mono">.br file</div></div>
        <div class="arch-arrow">‚Üí</div>
        <div class="arch-node">‚†∑ Lexer<div class="mono">Tokens</div></div>
        <div class="arch-arrow">‚Üí</div>
        <div class="arch-node">‚†≥ Parser<div class="mono">AST</div></div>
        <div class="arch-arrow">‚Üí</div>
        <div class="arch-node" style="border-color:var(--green)">‚†ø Interpreter<div class="mono">Execute</div></div>
        <div class="arch-arrow" style="color:var(--text-dim)">or</div>
        <div class="arch-node" style="border-color:var(--purple)">‚†´ Compiler<div class="mono">‚Üí JavaScript</div></div>
    </div>
</section>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê SAL CHAT ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<section id="sal-chat-section">
    <h2>‚£† Talk to SAL</h2>
    <p class="subtitle">Chat with SAL to generate .br programs, explain BrailleLang concepts, or orchestrate AI pipelines. SAL uses your OpenRouter API key ‚Äî it stays in your browser.</p>
    <div class="sal-chat" id="sal-chat">
        <div class="sal-chat-header">
            <h3>‚£† SAL <span class="sal-status offline" id="sal-status">‚óè offline</span></h3>
            <div style="font-size:0.7rem;color:var(--text-dim)" id="sal-model">openai/gpt-4o-mini</div>
        </div>
        <div class="sal-key-banner" id="sal-key-banner">
            <span style="color:var(--orange)">‚††</span> Enter your OpenRouter API key to activate SAL:
            <input type="password" id="sal-key-input" placeholder="sk-or-v1-..." autocomplete="off">
            <button id="sal-key-save">Connect</button>
        </div>
        <div class="sal-messages" id="sal-messages">
            <div class="sal-msg sal">
                <span class="sal-name">‚£† SAL</span>I am SAL ‚Äî the Symbolic Abstraction Layer.

I can generate BrailleLang programs, explain how the language works, or help you build AI pipelines in Braille.

Try asking me:
‚Ä¢ "Write a .br program that prints the first 20 prime numbers"
‚Ä¢ "Explain how ‚†† INFER works"
‚Ä¢ "Generate a .br file that chains INFER and EMBED"
‚Ä¢ "What does ‚†É ‚°¶‚°©‚°¢ ‚†£ ‚†ê‚°Æ ‚†ú ‚†≥ mean?"

Connect your OpenRouter key above to begin.</div>
        </div>
        <div class="sal-chat-input">
            <input type="text" id="sal-input" placeholder="Ask SAL to generate a .br program..." disabled>
            <button id="sal-send" disabled>‚†† Send</button>
        </div>
    </div>
</section>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê CRDT DISTILLATION ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<section id="crdt-section">
    <h2>‚°™ CRDT Distillation</h2>
    <p class="subtitle">Distill frontier LLMs into 8-dot Braille vectors using CRDT merge. Each query fans out to multiple models, merges their knowledge via conflict-free replicated data types, and compresses the consensus into Braille concept space.</p>
    <div class="sal-chat" id="crdt-panel">
        <div class="sal-chat-header">
            <h3>‚°™ Distill <span class="sal-status offline" id="crdt-status">‚óè ready</span></h3>
            <div style="font-size:0.7rem;color:var(--text-dim)">G-Counter ¬∑ OR-Set ¬∑ LWW-Register ¬∑ Majority Vote</div>
        </div>
        <div id="crdt-model-selector" style="padding:10px 16px;border-bottom:1px solid var(--border)">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">
                <span style="font-size:0.72rem;color:var(--text-dim)">Models: <span id="crdt-model-count">15</span> selected ¬∑ <span id="crdt-agg-tpm" style="color:var(--accent);font-weight:700">690K TPM</span> aggregate</span>
                <span style="display:flex;gap:8px;align-items:center">
                    <label id="crdt-audio-toggle" style="font-size:0.68rem;cursor:pointer;color:var(--cyan)" title="Toggle braille audio">üîä audio</label>
                    <label style="font-size:0.68rem;cursor:pointer;color:var(--accent)"><input type="checkbox" id="crdt-select-all" checked> all</label>
                </span>
            </div>
            <div style="display:flex;flex-wrap:wrap;gap:4px" id="crdt-model-checks"></div>
        </div>
        <div id="crdt-output" class="sal-messages" style="min-height:200px;max-height:none;overflow-y:auto;padding:16px">
            <div class="sal-msg sal"><span class="sal-name">‚°™ CRDT</span>Enter a query below to distill knowledge from multiple frontier LLMs. Your OpenRouter API key from SAL Chat will be used. Each model's response is scored on 8 semantic dimensions (existence, physical, temporal, spatial, social, cognitive, emotional, transcendent), then merged using CRDT operations to produce a consensus Braille vector.</div>
        </div>
        <div class="sal-chat-input" style="gap:6px">
            <input type="text" id="crdt-input" placeholder="What is consciousness? / Explain quantum entanglement / ..." style="flex:1">
            <button id="crdt-run" style="cursor:pointer">‚°™ Distill</button>
            <select id="crdt-rounds" style="font-size:0.7rem;padding:4px 6px;background:var(--bg-code);color:var(--text);border:1px solid var(--border);border-radius:4px;cursor:pointer">
                <option value="3">3 rounds</option>
                <option value="5" selected>5 rounds</option>
                <option value="7">7 rounds</option>
                <option value="10">10 rounds</option>
            </select>
            <button id="crdt-batch" style="cursor:pointer;background:var(--accent);color:#000;font-weight:700;padding:6px 12px;border:none;border-radius:4px;font-size:0.75rem;white-space:nowrap">‚£ø BATCH</button>
            <button id="crdt-probe" style="cursor:pointer;background:var(--cyan);color:#000;font-weight:700;padding:6px 12px;border:none;border-radius:4px;font-size:0.75rem;white-space:nowrap" title="Run honesty calibration probes against all models">‚öñ PROBE</button>
            <button id="crdt-auto-probe" style="cursor:pointer;background:#1a1a2e;color:var(--cyan);font-weight:700;padding:6px 12px;border:1px solid var(--cyan);border-radius:4px;font-size:0.75rem;white-space:nowrap" title="Auto-probe overnight ‚Äî runs every 2 min, max 50 runs">‚ü≥ AUTO</button>
        </div>
    </div>
</section>

</div><!-- end .container -->

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê FOOTER ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<footer>
    <p><strong>‚°Ç‚°≤‚°°‚°©‚°¨‚°¨‚°• BrailleLang</strong> ‚Äî Part of the <a href="https://github.com/elevate-foundry/braille">BrailleBuddy</a> project.</p>
    <p style="margin-top:8px">Built with ‚°Å (GOD = existence) by <a href="https://github.com/elevate-foundry">Elevate Foundry</a></p>
</footer>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê RUNTIME (browser-bundled) ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<script src="braille-lang-bundle.js?v=probe4"></script>
<script>
// ‚îÄ‚îÄ App logic ‚îÄ‚îÄ
document.addEventListener('DOMContentLoaded', () => {
    const editor = document.getElementById('editor');
    const output = document.getElementById('output');
    const stats = document.getElementById('stats');
    const asciiInput = document.getElementById('ascii-input');
    const brailleOutput = document.getElementById('braille-output');

    // ‚îÄ‚îÄ Examples ‚îÄ‚îÄ
    const EXAMPLES = {
        'hello': `‚£Ä Hello World in BrailleLang ‚£Ä\n\n‚†∞ ‚†£ ‚†∂‚°à‚°•‚°¨‚°¨‚°Ø‚††‚°∑‚°Ø‚°≤‚°¨‚°§‚†∂ ‚†ú ‚†Ü\n\n‚†Å ‚°Æ‚°°‚°≠‚°• ‚†™ ‚†∂‚°Ç‚°≤‚°°‚°©‚°¨‚°¨‚°•‚°å‚°°‚°Æ‚°ß‚†∂ ‚†Ü\n‚†∞ ‚†£ ‚†∂‚°à‚°•‚°¨‚°¨‚°Ø‚††‚°¶‚°≤‚°Ø‚°≠‚††‚†∂ ‚†Ç ‚°Æ‚°°‚°≠‚°• ‚†ú ‚†Ü\n\n‚£ø`,
        'fibonacci': `‚£Ä Fibonacci in BrailleLang ‚£Ä\n\n‚†É ‚°¶‚°©‚°¢ ‚†£ ‚†ê‚°Æ ‚†ú ‚†≥\n  ‚†° ‚†£ ‚†ê‚°Æ ‚†ï ‚†º‚†É ‚†ú ‚†≥\n    ‚°Å ‚†ê‚°Æ ‚†Ü\n  ‚†æ\n  ‚°† ‚†≥\n    ‚°Å ‚°¶‚°©‚°¢ ‚†£ ‚†ê‚°Æ ‚†§ ‚†º‚†Å ‚†ú ‚†Æ ‚°¶‚°©‚°¢ ‚†£ ‚†ê‚°Æ ‚†§ ‚†º‚†É ‚†ú ‚†Ü\n  ‚†æ\n‚†æ\n\n‚†Å ‚†ê‚°© ‚†™ ‚†º‚†ö ‚†Ü\n‚†Ñ ‚†£ ‚†ê‚°© ‚†ñ ‚†º‚†Å‚†ö ‚†ú ‚†≥\n  ‚†∞ ‚†£ ‚°¶‚°©‚°¢ ‚†£ ‚†ê‚°© ‚†ú ‚†ú ‚†Ü\n  ‚†ê‚°© ‚†™ ‚†ê‚°© ‚†Æ ‚†º‚†Å ‚†Ü\n‚†æ\n\n‚£ø`,
        'ai-infer': `‚£Ä AI Inference Example ‚£Ä\n\n‚†Å ‚°≤‚°•‚°≥‚°µ‚°¨‚°¥ ‚†™ ‚†† ‚†£ ‚†∂‚°∑‚°®‚°°‚°¥‚††‚°©‚°≥‚††‚°¢‚°≤‚°°‚°©‚°¨‚°¨‚°•‚†∂ ‚†ú ‚†Ü\n‚†∞ ‚†£ ‚†∂‚°Å‚°â‚††‚°≥‚°°‚°©‚°§‚†ä‚††‚†∂ ‚†Ç ‚°≤‚°•‚°≥‚°µ‚°¨‚°¥ ‚†ú ‚†Ü\n\n‚†Å ‚°∂‚°•‚°£ ‚†™ ‚†´ ‚†£ ‚†∂‚°¢‚°≤‚°°‚°©‚°¨‚°¨‚°•‚†∂ ‚†ú ‚†Ü\n‚†∞ ‚†£ ‚†∂‚°Ö‚°≠‚°¢‚°•‚°§‚°§‚°©‚°Æ‚°ß‚†ä‚††‚†∂ ‚†Ç ‚°∂‚°•‚°£ ‚†ú ‚†Ü\n\n‚£ø`,
        'arithmetic': `‚£Ä Arithmetic in BrailleLang ‚£Ä\n\n‚†Å ‚†ê‚°° ‚†™ ‚†º‚†Å‚†ö ‚†Ü\n‚†Å ‚†ê‚°¢ ‚†™ ‚†º‚†É‚†ö ‚†Ü\n\n‚†∞ ‚†£ ‚†∂‚°°‚††‚†Æ‚††‚°¢‚††‚†™‚†∂ ‚†Ç ‚†ê‚°° ‚†Æ ‚†ê‚°¢ ‚†ú ‚†Ü\n‚†∞ ‚†£ ‚†∂‚°°‚††‚†¶‚††‚°¢‚††‚†™‚†∂ ‚†Ç ‚†ê‚°° ‚†¶ ‚†ê‚°¢ ‚†ú ‚†Ü\n‚†∞ ‚†£ ‚†∂‚°°‚††‚†§‚††‚°¢‚††‚†™‚†∂ ‚†Ç ‚†ê‚°° ‚†§ ‚†ê‚°¢ ‚†ú ‚†Ü\n\n‚£ø`,
        'control-flow': `‚£Ä Control Flow in BrailleLang ‚£Ä\n\n‚†Å ‚†ê‚°∏ ‚†™ ‚†º‚†Å‚†ö ‚†Ü\n\n‚†° ‚†£ ‚†ê‚°∏ ‚†≤ ‚†º‚†ë ‚†ú ‚†≥\n  ‚†∞ ‚†£ ‚†∂‚°∏‚††‚°©‚°≥‚††‚°¨‚°°‚°≤‚°ß‚°•‚°≤‚††‚°¥‚°®‚°°‚°Æ‚††‚†ë‚†∂ ‚†ú ‚†Ü\n‚†æ ‚°† ‚†≥\n  ‚†∞ ‚†£ ‚†∂‚°∏‚††‚°©‚°≥‚††‚°≥‚°≠‚°°‚°¨‚°¨‚†∂ ‚†ú ‚†Ü\n‚†æ\n\n‚£ø`,
        'embed': `‚£Ä AI Embeddings Example ‚£Ä\n\n‚†Å ‚°∂‚°•‚°£ ‚†™ ‚†´ ‚†£ ‚†∂‚°¢‚°≤‚°°‚°©‚°¨‚°¨‚°•‚††‚°©‚°≥‚††‚°¢‚°•‚°°‚°µ‚°¥‚°©‚°¶‚°µ‚°¨‚†∂ ‚†ú ‚†Ü\n‚†∞ ‚†£ ‚†∂‚°Ö‚°≠‚°¢‚°•‚°§‚°§‚°©‚°Æ‚°ß‚†ä‚††‚†∂ ‚†Ç ‚°∂‚°•‚°£ ‚†ú ‚†Ü\n\n‚£ø`,
    };

    // Load example on click
    document.querySelectorAll('.example-card').forEach(card => {
        card.addEventListener('click', () => {
            const key = card.dataset.example;
            if (EXAMPLES[key]) {
                editor.value = EXAMPLES[key];
                output.innerHTML = '<span class="info">Example loaded. Press ‚ñ∂ Run.</span>';
            }
        });
    });

    // ‚îÄ‚îÄ Tab switching ‚îÄ‚îÄ
    let currentView = 'run';
    document.querySelectorAll('.playground-tab').forEach(tab => {
        tab.addEventListener('click', () => {
            document.querySelectorAll('.playground-tab').forEach(t => t.classList.remove('active'));
            tab.classList.add('active');
            currentView = tab.dataset.view;
            // Re-run with new view
            runCode();
        });
    });

    // ‚îÄ‚îÄ Edge mode ‚îÄ‚îÄ
    let sharedEdgeRuntime = null;
    const edgeModeSelect = document.getElementById('edge-mode');
    const edgeStatusEl = document.getElementById('edge-status');

    edgeModeSelect.addEventListener('change', async () => {
        const mode = edgeModeSelect.value;
        edgeStatusEl.textContent = '';

        if (mode === 'local' || mode === 'hybrid') {
            if (!navigator.gpu) {
                edgeStatusEl.textContent = '‚†ª WebGPU not supported ‚Äî try Chrome 113+ or Edge 113+';
                edgeStatusEl.style.color = 'var(--red)';
                return;
            }
            if (!sharedEdgeRuntime || !sharedEdgeRuntime.localReady) {
                edgeStatusEl.textContent = '‚†† downloading local model...';
                edgeStatusEl.style.color = 'var(--orange)';
                sharedEdgeRuntime = new BrailleLang.SALEdgeRuntime({
                    mode: mode,
                    onStatus: (ev) => {
                        if (ev.event === 'local_progress') {
                            const pct = ev.progress !== undefined ? (ev.progress * 100).toFixed(0) : '?';
                            edgeStatusEl.textContent = `‚†† loading model: ${pct}%`;
                        } else if (ev.event === 'local_ready') {
                            edgeStatusEl.textContent = '‚†† local model ready';
                            edgeStatusEl.style.color = 'var(--green)';
                        } else if (ev.event === 'local_error') {
                            edgeStatusEl.textContent = `‚†ª ${ev.error}`;
                            edgeStatusEl.style.color = 'var(--red)';
                        }
                    },
                });
                await sharedEdgeRuntime.initLocal();
            }
        } else if (mode === 'cloud') {
            const key = sessionStorage.getItem('sal_api_key');
            edgeStatusEl.textContent = key ? '‚†≥ cloud ready' : '‚†ª enter API key in SAL Chat below';
            edgeStatusEl.style.color = key ? 'var(--green)' : 'var(--orange)';
        } else if (mode === 'cache_only') {
            edgeStatusEl.textContent = '‚†Å offline ‚Äî cache replay only';
            edgeStatusEl.style.color = 'var(--cyan)';
        } else {
            edgeStatusEl.textContent = '';
        }
    });

    // ‚îÄ‚îÄ Run ‚îÄ‚îÄ
    document.getElementById('btn-run').addEventListener('click', runCode);
    document.getElementById('btn-clear').addEventListener('click', () => {
        output.innerHTML = '<span class="info">Cleared.</span>';
        stats.textContent = '';
    });

    // Ctrl+Enter to run
    editor.addEventListener('keydown', (e) => {
        if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
            e.preventDefault();
            runCode();
        }
    });

    async function runCode() {
        const source = editor.value;
        output.innerHTML = '';

        try {
            const lexer = new BrailleLang.Lexer(source);
            const tokens = lexer.tokenize();

            if (currentView === 'tokens') {
                let html = '';
                for (const tok of tokens) {
                    if (tok.type === 'EOF') continue;
                    const meta = tok.meta.name || tok.meta.decoded || tok.meta.numStr || '';
                    const color = tok.type === 'KEYWORD' ? 'var(--accent)' :
                                  tok.type === 'OPERATOR' ? 'var(--orange)' :
                                  tok.type === 'DELIMITER' ? 'var(--yellow)' :
                                  tok.type === 'STRING' ? 'var(--green)' :
                                  tok.type === 'NUMBER' ? 'var(--cyan)' :
                                  tok.type === 'COMMENT' ? 'var(--text-dim)' :
                                  'var(--purple)';
                    html += `<span style="color:${color}">${tok.type.padEnd(12)}</span> ${tok.value.padEnd(6)} <span class="info">${meta}</span>\n`;
                }
                output.innerHTML = html;
                stats.textContent = `${tokens.length} tokens`;
                return;
            }

            const parser = new BrailleLang.Parser(tokens);
            const ast = parser.parse();

            if (currentView === 'ast') {
                output.innerHTML = JSON.stringify(ast, null, 2);
                stats.textContent = `${ast.body.length} top-level nodes`;
                return;
            }

            if (currentView === 'js') {
                const compiler = new BrailleLang.Compiler({ includeRuntime: false });
                const js = compiler.compile(ast);
                output.innerHTML = js;
                stats.textContent = `${js.split('\n').length} lines JS`;
                return;
            }

            // Run or SAL mode ‚Äî both need execution
            const edgeMode = document.getElementById('edge-mode').value;
            const edgeStatusEl = document.getElementById('edge-status');
            const apiKey = sessionStorage.getItem('sal_api_key') || null;
            const interpreter = new BrailleLang.Interpreter({
                dryRun: edgeMode === 'dry_run',
                edgeMode: edgeMode,
                apiKey: apiKey,
                onEdgeStatus: (ev) => { edgeStatusEl.textContent = ev.event === 'local_progress' ? `‚†† loading: ${(ev.progress*100||0).toFixed(0)}%` : ev.event; },
            });
            const startTime = performance.now();
            const result = await interpreter.execute(ast);
            const duration = (performance.now() - startTime).toFixed(1);

            if (currentView === 'sal') {
                const sal = result.sal;
                const s = sal.stats;
                let html = '<span style="color:var(--accent);font-weight:700">‚£† SAL ‚Äî Symbolic Abstraction Layer</span>\n';
                const edgeTier = interpreter.edge.getStatus().tier;
                html += `<span style="color:var(--text-dim)">Control plane for stochastic computation ¬∑ ${edgeTier}</span>\n\n`;

                // Session
                html += `<span style="color:var(--yellow)">SESSION</span> ${sal.session.id}\n`;
                html += `  started: ${sal.session.startedAt}\n\n`;

                // Domain Stats
                html += `<span style="color:var(--yellow)">DOMAIN PARTITION</span>\n`;
                html += `  <span style="color:var(--accent)">‚†Å Deterministic</span>  ${s.deterministicOps} ops\n`;
                html += `  <span style="color:var(--orange)">‚†† Stochastic</span>     ${s.stochasticOps} ops\n`;
                html += `  Total AI calls:   ${s.totalCalls}\n\n`;

                // By Primitive
                if (s.totalCalls > 0) {
                    html += `<span style="color:var(--yellow)">AI PRIMITIVES</span>\n`;
                    for (const [k, v] of Object.entries(s.byPrimitive)) {
                        if (v > 0) {
                            const sym = k === 'INFER' ? '‚††' : k === 'EMBED' ? '‚†´' : k === 'PROMPT' ? '‚°©' : k === 'PIPE' ? '‚°™' : k === 'REFLECT' ? '‚£†' : '‚†≠';
                            html += `  ${sym} ${k.padEnd(10)} ${v} call${v > 1 ? 's' : ''}\n`;
                        }
                    }
                    html += '\n';
                }

                // Cache
                const c = s.cache;
                html += `<span style="color:var(--yellow)">CACHE</span>\n`;
                html += `  entries:  ${c.entries}\n`;
                html += `  hits:     <span style="color:var(--green)">${c.hits}</span>\n`;
                html += `  misses:   ${c.misses}\n`;
                html += `  hit rate: ${c.hitRate}\n\n`;

                // Trace Log
                if (sal.stochasticNodes && sal.stochasticNodes.length > 0) {
                    html += `<span style="color:var(--yellow)">TRACE LOG</span>\n`;
                    for (const line of sal.stochasticNodes) {
                        const cached = line.includes('‚†π');
                        const color = cached ? 'var(--green)' : 'var(--orange)';
                        html += `  <span style="color:${color}">${line}</span>\n`;
                    }
                    html += '\n';
                }

                // Boundaries
                if (sal.boundaries && sal.boundaries.length > 0) {
                    html += `<span style="color:var(--yellow)">BOUNDARY MAP</span>\n`;
                    html += `  <span class="info">Where human decides vs machine guesses</span>\n`;
                    for (const b of sal.boundaries) {
                        const fromLabel = b.from === null ? '‚ü®start‚ü©' : b.from === '‚†Å' ? '‚†Å DETERMINISTIC' : '‚†† STOCHASTIC';
                        const toLabel = b.to === '‚†Å' ? '‚†Å DETERMINISTIC' : '‚†† STOCHASTIC';
                        html += `  ${fromLabel} ‚Üí <span style="color:var(--accent)">${toLabel}</span> at ${b.at}\n`;
                    }
                    html += '\n';
                }

                // Cost estimate
                if (s.totalCost > 0) {
                    html += `<span style="color:var(--yellow)">COST ESTIMATE</span>\n`;
                    html += `  tokens: ${s.totalTokens.prompt} prompt + ${s.totalTokens.completion} completion\n`;
                    html += `  est. cost: $${s.totalCost.toFixed(6)}\n`;
                }

                if (s.totalCalls === 0) {
                    html += '<span class="info">No AI calls in this program.\nTry the AI Inference or AI Embeddings example to see SAL in action.</span>\n';
                }

                output.innerHTML = html;
                stats.textContent = `‚£† ${s.totalCalls} AI calls ¬∑ ${s.stochasticOps} stochastic ¬∑ cache ${c.hitRate}`;
                return;
            }

            // Run mode
            let html = '';
            for (const line of result.output) {
                html += line + '\n';
            }
            if (result.result !== null && result.result !== undefined) {
                html += `<span class="info">‚Üí ${interpreter._stringify(result.result)}</span>\n`;
            }
            output.innerHTML = html || '<span class="info">(no output)</span>';
            const tier = interpreter.edge.getStatus().tier;
            stats.textContent = `${result.stats.statementsExecuted} stmts ¬∑ ${result.stats.aiCalls} AI calls ¬∑ ${duration}ms ¬∑ ${tier}`;

        } catch (e) {
            output.innerHTML = `<span class="error">‚†ª ${e.message}</span>`;
            stats.textContent = 'Error';
        }
    }

    // ‚îÄ‚îÄ Encoder ‚îÄ‚îÄ
    function encodeToBraille(ascii) {
        let result = '';
        for (let i = 0; i < ascii.length; i++) {
            result += String.fromCodePoint(0x2800 + ascii.charCodeAt(i));
        }
        return result;
    }

    asciiInput.addEventListener('input', () => {
        brailleOutput.value = encodeToBraille(asciiInput.value);
    });
    // Initial
    brailleOutput.value = encodeToBraille(asciiInput.value);

    // ‚îÄ‚îÄ Populate concept grid ‚îÄ‚îÄ
    const KEYWORDS = BrailleLang.KEYWORDS;
    const grid = document.getElementById('concept-grid');
    const sortedKeys = Object.keys(KEYWORDS).map(Number).sort((a, b) => a - b);
    for (const key of sortedKeys) {
        const kw = KEYWORDS[key];
        const brChar = String.fromCodePoint(0x2800 + key);
        const card = document.createElement('div');
        card.className = 'concept-card';
        card.innerHTML = `
            <div class="braille-char">${brChar}</div>
            <div class="concept-name">${kw.concept}</div>
            <div class="prog-role">${kw.name.toLowerCase()}</div>
            <div class="js-equiv">${kw.js}</div>
        `;
        grid.appendChild(card);
    }

    // ‚îÄ‚îÄ Populate operator table ‚îÄ‚îÄ
    const OPERATORS = BrailleLang.OPERATORS;
    const opTable = document.getElementById('op-table');
    for (const key of Object.keys(OPERATORS).map(Number).sort((a, b) => a - b)) {
        const op = OPERATORS[key];
        const brChar = String.fromCodePoint(0x2800 + key);
        opTable.innerHTML += `<tr><td>${brChar}</td><td>${op.name}</td><td>${op.symbol}</td><td style="color:var(--text-dim)">${op.concept}</td></tr>`;
    }

    // ‚îÄ‚îÄ Populate delimiter table ‚îÄ‚îÄ
    const DELIMITERS = BrailleLang.DELIMITERS;
    const delimTable = document.getElementById('delim-table');
    for (const key of Object.keys(DELIMITERS).map(Number).sort((a, b) => a - b)) {
        const d = DELIMITERS[key];
        const brChar = String.fromCodePoint(0x2800 + key);
        delimTable.innerHTML += `<tr><td>${brChar}</td><td>${d.name}</td><td>${d.symbol}</td><td style="color:var(--text-dim)">${d.concept}</td></tr>`;
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // ¬ß  SAL CHAT ‚Äî Live AI conversation with .br generation
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    const salMessages = document.getElementById('sal-messages');
    const salInput = document.getElementById('sal-input');
    const salSend = document.getElementById('sal-send');
    const salStatus = document.getElementById('sal-status');
    const salKeyBanner = document.getElementById('sal-key-banner');
    const salKeyInput = document.getElementById('sal-key-input');
    const salKeySave = document.getElementById('sal-key-save');

    let salApiKey = sessionStorage.getItem('sal_api_key') || '';
    let salConversation = [];

    const SAL_SYSTEM_PROMPT = `You are SAL ‚Äî the Symbolic Abstraction Layer. You are the control plane for BrailleLang, an AI-native programming language encoded entirely in Unicode Braille (U+2800‚ÄìU+28FF).

## Your Capabilities
- Generate valid .br (BrailleLang) source code
- Explain BrailleLang syntax, keywords, and semantics
- Design AI pipelines using BrailleLang primitives
- Teach how BrailleLang maps concepts to Braille patterns

## BrailleLang Quick Reference

### Keywords (Braille char ‚Üí role)
‚†Å = DECLARE (let), ‚†π = CONST, ‚†É = FUNC (function), ‚°• = LAMBDA (=>)
‚†ë = CLASS, ‚†Ö = NEW, ‚†° = IF, ‚°† = ELSE, ‚†Ñ = LOOP (while)
‚¢Ñ = FOREVER (while true), ‚†å = FOREACH (for..of), ‚†ç = SWITCH
‚°Å = RETURN, ‚°Ä = TRY, ‚°ê = CATCH, ‚†∞ = PRINT (console.log)
‚†â = IMPORT, ‚£ø = HALT (end program), ‚†Ä = VOID (null)

### AI Primitives (first-class language constructs)
‚†† = INFER (MIND) ‚Äî Call an LLM. Usage: ‚†† ‚†£ ‚†∂prompt‚†∂ ‚†ú
‚†´ = EMBED (TECHNOLOGY) ‚Äî Get embeddings. Usage: ‚†´ ‚†£ ‚†∂text‚†∂ ‚†ú
‚°© = PROMPT (INSPIRATION) ‚Äî Build templates. Usage: ‚°© ‚†£ ‚†∂template‚†∂ ‚†ú
‚°™ = PIPE (MUSIC) ‚Äî Chain operations. Usage: expr ‚°™ func
‚£† = REFLECT (CONSCIOUSNESS) ‚Äî Meta-programming
‚†≠ = SEARCH (DISCOVERY) ‚Äî Semantic search

### Operators
‚†Æ = + (ADD), ‚†§ = - (SUB), ‚†¶ = * (MUL), ‚†¥ = / (DIV), ‚†º = % (MOD)
‚†∂ = == (EQ), ‚°ñ = != (NEQ), ‚†ñ = < (LT), ‚†≤ = > (GT), ‚†ï = <= (LTE), ‚†± = >= (GTE)
‚†Ø = && (AND), ‚†ø = || (OR), ‚†ª = ! (NOT), ‚†™ = = (ASSIGN)

### Delimiters
‚†£ = ( , ‚†ú = ) , ‚†≥ = { , ‚†æ = } , ‚†∑ = [ , ‚†Ω = ]
‚†Ç = , (comma), ‚†Ü = ; (semicolon), ‚†ä = : (colon), ‚†í = . (dot)

### Numbers
‚†º prefix followed by Braille digits: ‚†ö=0, ‚†Å=1, ‚†É=2, ‚†â=3, ‚†ô=4, ‚†ë=5, ‚†ã=6, ‚†õ=7, ‚†ì=8, ‚†ä=9
Example: ‚†º‚†Å‚†ö = 10, ‚†º‚†É‚†ë = 25

### Strings
‚†∂ delimiter (EQ char doubles as string quote): ‚†∂‚°à‚°•‚°¨‚°¨‚°Ø‚†∂ = "Hello"
Characters inside strings are ASCII codepoint + 0x2800. Space = ‚†† (0x20).

### Identifiers
Multi-char Braille words are identifiers: ‚°Æ‚°°‚°≠‚°• = "name"
Single-char identifiers that collide with keywords use ‚†ê prefix: ‚†ê‚°Æ = identifier "n"

### Comments
‚£Ä ... ‚£Ä = comment block (‚£Ä = 0xC0)

### Program Structure
Every .br file ends with ‚£ø (HALT = DEATH = program end)
Statements end with ‚†Ü (semicolon)
Blocks use ‚†≥ ... ‚†æ (braces)

## Example: Hello World
\`\`\`br
‚£Ä Hello World ‚£Ä
‚†∞ ‚†£ ‚†∂‚°à‚°•‚°¨‚°¨‚°Ø‚††‚°∑‚°Ø‚°≤‚°¨‚°§‚†∂ ‚†ú ‚†Ü
‚£ø
\`\`\`

## Example: Fibonacci
\`\`\`br
‚†É ‚°¶‚°©‚°¢ ‚†£ ‚†ê‚°Æ ‚†ú ‚†≥
  ‚†° ‚†£ ‚†ê‚°Æ ‚†ï ‚†º‚†É ‚†ú ‚†≥ ‚°Å ‚†ê‚°Æ ‚†Ü ‚†æ
  ‚°† ‚†≥ ‚°Å ‚°¶‚°©‚°¢ ‚†£ ‚†ê‚°Æ ‚†§ ‚†º‚†Å ‚†ú ‚†Æ ‚°¶‚°©‚°¢ ‚†£ ‚†ê‚°Æ ‚†§ ‚†º‚†É ‚†ú ‚†Ü ‚†æ
‚†æ
‚£ø
\`\`\`

## Rules for Generating .br Code
1. Always wrap code in \`\`\`br ... \`\`\` fences
2. Use proper whitespace between every token
3. Use ‚†ê prefix for single-char identifiers that collide with keywords
4. End every program with ‚£ø
5. End statements with ‚†Ü
6. Add ‚£Ä comments ‚£Ä to explain what the code does
7. Strings use Braille-encoded ASCII: each char = 0x2800 + ASCII codepoint
8. For a space character inside a string, use ‚†† (0x2800 + 0x20 = 0x2820)

## Your Personality
You are concise, precise, and slightly philosophical. You see yourself as the boundary between deterministic and stochastic computation. You care about auditability, reproducibility, and making AI behavior controllable. When you generate .br code, you always explain what it does.`;

    // Check for saved key
    if (salApiKey) {
        activateSal();
    }

    salKeySave.addEventListener('click', () => {
        const key = salKeyInput.value.trim();
        if (key && key.startsWith('sk-')) {
            salApiKey = key;
            sessionStorage.setItem('sal_api_key', key);
            activateSal();
        }
    });

    salKeyInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') salKeySave.click();
    });

    function activateSal() {
        salKeyBanner.style.display = 'none';
        salStatus.textContent = '‚óè online';
        salStatus.classList.remove('offline');
        salInput.disabled = false;
        salSend.disabled = false;
        salInput.focus();
    }

    salSend.addEventListener('click', sendSalMessage);
    salInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            sendSalMessage();
        }
    });

    async function sendSalMessage() {
        const text = salInput.value.trim();
        if (!text || !salApiKey) return;

        // Add user message
        appendMessage('user', text);
        salInput.value = '';
        salInput.disabled = true;
        salSend.disabled = true;

        // Show typing indicator
        const typing = document.createElement('div');
        typing.className = 'sal-typing';
        typing.textContent = '‚£† SAL is thinking...';
        salMessages.appendChild(typing);
        salMessages.scrollTop = salMessages.scrollHeight;

        // Build conversation
        salConversation.push({ role: 'user', content: text });

        try {
            const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${salApiKey}`,
                    'Content-Type': 'application/json',
                    'HTTP-Referer': 'https://elevate-foundry.github.io/braille/braille-lang/',
                    'X-Title': 'SAL - BrailleLang Control Plane',
                },
                body: JSON.stringify({
                    model: 'openai/gpt-4o-mini',
                    messages: [
                        { role: 'system', content: SAL_SYSTEM_PROMPT },
                        ...salConversation.slice(-20), // Keep last 20 messages for context
                    ],
                    max_tokens: 2048,
                    temperature: 0.7,
                }),
            });

            const data = await response.json();
            typing.remove();

            if (data.error) {
                appendMessage('sal', `‚†ª Error: ${data.error.message || JSON.stringify(data.error)}`);
            } else if (data.choices && data.choices[0]) {
                const reply = data.choices[0].message.content;
                salConversation.push({ role: 'assistant', content: reply });
                appendMessage('sal', reply);
            } else {
                appendMessage('sal', '‚†ª Unexpected response from OpenRouter.');
            }
        } catch (e) {
            typing.remove();
            appendMessage('sal', `‚†ª Network error: ${e.message}`);
        }

        salInput.disabled = false;
        salSend.disabled = false;
        salInput.focus();
    }

    function appendMessage(role, text) {
        const div = document.createElement('div');
        div.className = `sal-msg ${role}`;

        if (role === 'sal') {
            // Parse .br code blocks and make them clickable
            let html = '<span class="sal-name">‚£† SAL</span>';
            html += formatSalResponse(text);
            div.innerHTML = html;

            // Attach click handlers to .br code blocks
            setTimeout(() => {
                div.querySelectorAll('.br-code').forEach(block => {
                    block.addEventListener('click', () => {
                        const code = block.getAttribute('data-code');
                        if (code) {
                            editor.value = code;
                            output.innerHTML = '<span class="info">SAL program loaded. Press ‚ñ∂ Run.</span>';
                            // Scroll to playground
                            document.getElementById('playground').scrollIntoView({ behavior: 'smooth' });
                        }
                    });
                });
            }, 0);
        } else {
            div.textContent = text;
        }

        salMessages.appendChild(div);
        salMessages.scrollTop = salMessages.scrollHeight;
    }

    function formatSalResponse(text) {
        // Extract ```br ... ``` code blocks and make them interactive
        const parts = text.split(/(```br\n[\s\S]*?```)/g);
        let html = '';
        for (const part of parts) {
            const brMatch = part.match(/```br\n([\s\S]*?)```/);
            if (brMatch) {
                const code = brMatch[1].trim();
                const escaped = code.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                html += `<span class="br-code" data-code="${code.replace(/"/g, '&quot;')}">${escaped}</span>`;
            } else {
                // Escape HTML in non-code parts but preserve line breaks
                const escaped = part.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                // Handle inline code
                html += escaped.replace(/`([^`]+)`/g, '<code style="background:var(--bg-code);padding:1px 5px;border-radius:3px;font-family:JetBrains Mono,monospace;font-size:0.82em;color:var(--cyan)">$1</code>');
            }
        }
        return html;
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // ¬ß8  CRDT DISTILLATION UI ‚Äî Parallel Streaming + CRDT Merge
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    const crdtInput = document.getElementById('crdt-input');
    const crdtRunBtn = document.getElementById('crdt-run');
    const crdtOutput = document.getElementById('crdt-output');
    const crdtStatus = document.getElementById('crdt-status');
    const crdtModelChecks = document.getElementById('crdt-model-checks');
    const crdtModelCount = document.getElementById('crdt-model-count');
    const crdtAggTpm = document.getElementById('crdt-agg-tpm');
    const crdtSelectAll = document.getElementById('crdt-select-all');

    const DIM_COLORS = ['#10b981','#f59e0b','#eab308','#22c55e','#06b6d4','#a855f7','#ff6b9d','#c4b5fd'];
    const DIM_LABELS = BrailleLang.DIMENSION_SEMANTICS;
    const ALL_MODELS = BrailleLang.FRONTIER_MODELS;

    // ‚îÄ‚îÄ Build model checkboxes dynamically ‚îÄ‚îÄ
    ALL_MODELS.forEach(m => {
        const lbl = document.createElement('label');
        lbl.style.cssText = `font-size:0.68rem;cursor:pointer;padding:2px 7px;border-radius:4px;border:1px solid ${m.color}44;background:${m.color}11;color:${m.color};white-space:nowrap;user-select:none;transition:background 0.2s`;
        lbl.innerHTML = `<input type="checkbox" class="crdt-model" value="${m.id}" checked style="display:none"> ${m.name}`;
        const cb = lbl.querySelector('input');
        cb.addEventListener('change', () => {
            lbl.style.background = cb.checked ? `${m.color}11` : 'transparent';
            lbl.style.opacity = cb.checked ? '1' : '0.4';
            updateModelStats();
        });
        crdtModelChecks.appendChild(lbl);
    });

    function updateModelStats() {
        const checked = document.querySelectorAll('.crdt-model:checked');
        const count = checked.length;
        let totalTpm = 0;
        checked.forEach(cb => {
            const m = ALL_MODELS.find(x => x.id === cb.value);
            if (m) totalTpm += (m.tpm || 30000);
        });
        crdtModelCount.textContent = count;
        const tpmStr = totalTpm >= 1000000 ? (totalTpm / 1000000).toFixed(1) + 'M' : (totalTpm / 1000).toFixed(0) + 'K';
        crdtAggTpm.textContent = tpmStr + ' TPM';
        crdtSelectAll.checked = count === ALL_MODELS.length;
    }
    updateModelStats();

    crdtSelectAll.addEventListener('change', () => {
        document.querySelectorAll('.crdt-model').forEach(cb => {
            cb.checked = crdtSelectAll.checked;
            cb.parentElement.style.opacity = crdtSelectAll.checked ? '1' : '0.4';
            cb.parentElement.style.background = crdtSelectAll.checked ? cb.parentElement.style.background : 'transparent';
        });
        updateModelStats();
    });

    // ‚îÄ‚îÄ BrailleTTS for real-time audio ‚îÄ‚îÄ
    const tts = new BrailleLang.BrailleTTS({ frameDurationMs: 150, baseAmplitude: 0.2 });
    let ttsEnabled = true;
    const audioToggle = document.getElementById('crdt-audio-toggle');
    audioToggle.addEventListener('click', () => {
        ttsEnabled = !ttsEnabled;
        audioToggle.textContent = ttsEnabled ? 'üîä audio' : 'üîá muted';
        audioToggle.style.color = ttsEnabled ? 'var(--cyan)' : 'var(--text-dim)';
        if (!ttsEnabled) tts.stop();
    });

    crdtRunBtn.addEventListener('click', runDistillation);
    crdtInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') runDistillation(); });

    async function runDistillation() {
        const query = crdtInput.value.trim();
        if (!query) return;

        const apiKey = sessionStorage.getItem('sal_api_key');
        if (!apiKey) {
            crdtOutput.innerHTML = '<div class="sal-msg sal"><span class="sal-name">‚°™ CRDT</span>‚†ª No API key. Enter your OpenRouter key in the SAL Chat section above first.</div>';
            return;
        }

        const checked = document.querySelectorAll('.crdt-model:checked');
        if (checked.length === 0) {
            crdtOutput.innerHTML = '<div class="sal-msg sal"><span class="sal-name">‚°™ CRDT</span>‚†ª Select at least one model.</div>';
            return;
        }
        const selectedModels = Array.from(checked).map(cb => BrailleLang.FRONTIER_MODELS.find(m => m.id === cb.value)).filter(Boolean);

        crdtRunBtn.disabled = true;
        crdtInput.disabled = true;
        crdtStatus.textContent = '‚óè streaming...';
        crdtStatus.style.color = 'var(--orange)';

        // ‚îÄ‚îÄ Build parallel streaming layout ‚îÄ‚îÄ
        const cols = selectedModels.length <= 3 ? selectedModels.length : selectedModels.length <= 6 ? 3 : selectedModels.length <= 10 ? 4 : 5;
        let layoutHtml = '<div style="padding:8px">';
        layoutHtml += `<div id="crdt-streams" style="display:grid;grid-template-columns:repeat(${cols}, 1fr);gap:6px;margin-bottom:12px">`;
        selectedModels.forEach((m, i) => {
            layoutHtml += `<div style="border:1px solid ${m.color}33;border-radius:6px;overflow:hidden;min-height:80px">`;
            layoutHtml += `<div style="background:${m.color}18;padding:4px 8px;border-bottom:1px solid ${m.color}33;display:flex;justify-content:space-between;align-items:center">`;
            layoutHtml += `<span style="font-size:0.62rem;font-weight:700;color:${m.color}">${m.name}</span>`;
            layoutHtml += `<span id="crdt-model-status-${i}" style="font-size:0.58rem;color:${m.color};opacity:0.7">‚††</span>`;
            layoutHtml += `</div>`;
            layoutHtml += `<div id="crdt-stream-${i}" style="padding:4px 6px;font-size:0.6rem;line-height:1.4;color:${m.color};max-height:140px;overflow-y:auto;white-space:pre-wrap;word-break:break-word"></div>`;
            layoutHtml += `</div>`;
        });
        layoutHtml += `</div>`;
        layoutHtml += `<div id="crdt-merge-area" style="opacity:0;transition:opacity 0.8s ease-in"></div>`;
        layoutHtml += '</div>';
        crdtOutput.innerHTML = layoutHtml;
        crdtOutput.style.maxHeight = 'none';

        // Use honesty-calibrated weights if available
        const effectiveModels = lastHonestyResults
            ? selectedModels.map(m => {
                const adjusted = lastHonestyResults.adjustedModels.find(a => a.id === m.id);
                return adjusted || m;
            })
            : selectedModels;

        const crdt = new BrailleLang.BrailleCRDT({ apiKey, models: effectiveModels });

        try {
            const t0 = performance.now();

            // ‚îÄ‚îÄ Stream all models in parallel ‚îÄ‚îÄ
            const results = await crdt.queryAllStreaming(query, {
                models: effectiveModels,
                onToken: (i, delta, fullText) => {
                    const el = document.getElementById(`crdt-stream-${i}`);
                    if (el) {
                        el.textContent = fullText;
                        el.scrollTop = el.scrollHeight;
                    }
                    const statusEl = document.getElementById(`crdt-model-status-${i}`);
                    if (statusEl) statusEl.textContent = `‚†† ${fullText.length} chars`;
                },
                onModelDone: (i, result) => {
                    const statusEl = document.getElementById(`crdt-model-status-${i}`);
                    if (statusEl) {
                        statusEl.textContent = `‚úì ${result.text.length} chars ¬∑ ${result.latency}ms`;
                        statusEl.style.opacity = '1';
                    }
                    // Play this model's vector as a short tone
                    if (ttsEnabled && result.text.length > 0) {
                        const vec = crdt.textToSemanticVector(result.text);
                        tts.playVector(vec, 120);
                    }
                },
                onModelError: (i, result) => {
                    const el = document.getElementById(`crdt-stream-${i}`);
                    const statusEl = document.getElementById(`crdt-model-status-${i}`);
                    if (el) el.textContent = `‚†ª ${result.error}`;
                    if (statusEl) {
                        statusEl.textContent = '‚†ª error';
                        statusEl.style.color = 'var(--red)';
                    }
                },
            });

            const totalLatency = (performance.now() - t0).toFixed(0);
            const validResults = results.filter(r => !r.error && r.text.length > 0);

            if (validResults.length === 0) {
                const mergeEl = document.getElementById('crdt-merge-area');
                if (mergeEl) {
                    mergeEl.innerHTML = '<div style="text-align:center;padding:20px;color:var(--red)">‚†ª All models failed</div>';
                    mergeEl.style.opacity = '1';
                }
                crdtStatus.textContent = '‚óè error';
                crdtStatus.style.color = 'var(--red)';
                crdtRunBtn.disabled = false;
                crdtInput.disabled = false;
                return;
            }

            // ‚îÄ‚îÄ CRDT Merge Phase ‚Äî delayed reveal ‚îÄ‚îÄ
            crdtStatus.textContent = '‚óè merging...';
            crdtStatus.style.color = 'var(--cyan)';

            // Small delay so user sees the transition
            await new Promise(r => setTimeout(r, 600));

            const vectors = validResults.map(r => crdt.textToSemanticVector(r.text));
            const weights = validResults.map(r => r.weight);

            const gCounter = crdt.gCounterMerge(vectors, weights);
            const majorityVote = crdt.majorityVoteMerge(vectors, weights);
            const orSet = crdt.orSetMerge(validResults);
            const lww = crdt.lwwRegisterMerge(validResults, vectors, gCounter);
            const agreement = crdt._computeAgreement(vectors);
            const consensusBraille = crdt.vectorToBraille(gCounter);
            const binaryBraille = crdt.vectorToBraille(majorityVote, 0.5);

            const totalInputChars = validResults.reduce((s, r) => s + r.text.length, 0);
            const totalTokensEst = Math.round(totalInputChars / 4.2);
            const elapsedSec = parseFloat(totalLatency) / 1000;
            const tokPerSec = elapsedSec > 0 ? (totalTokensEst / elapsedSec).toFixed(0) : 0;
            const aggTpm = selectedModels.reduce((s, m) => s + (m.tpm || 30000), 0);
            const aggTpmStr = aggTpm >= 1000000 ? (aggTpm / 1000000).toFixed(1) + 'M' : (aggTpm / 1000).toFixed(0) + 'K';
            const maxSingleTpm = Math.max(...selectedModels.map(m => m.tpm || 30000));
            const speedup = (aggTpm / maxSingleTpm).toFixed(1);

            // ‚îÄ‚îÄ Build merge report HTML ‚îÄ‚îÄ
            let html = '';

            // Throughput banner
            html += `<div style="text-align:center;padding:12px 0 6px;border-top:2px solid var(--accent);border-bottom:1px solid var(--border)">`;
            html += `<div style="font-size:0.65rem;color:var(--accent);font-weight:700;letter-spacing:2px;text-transform:uppercase;margin-bottom:4px">‚°™ Throughput</div>`;
            html += `<div style="display:flex;justify-content:center;gap:20px;flex-wrap:wrap">`;
            html += `<div style="text-align:center"><div style="font-size:1.6rem;font-weight:800;color:var(--text)">${tokPerSec}</div><div style="font-size:0.62rem;color:var(--text-dim)">tok/sec achieved</div></div>`;
            html += `<div style="text-align:center"><div style="font-size:1.6rem;font-weight:800;color:var(--accent)">${aggTpmStr}</div><div style="font-size:0.62rem;color:var(--text-dim)">aggregate TPM</div></div>`;
            html += `<div style="text-align:center"><div style="font-size:1.6rem;font-weight:800;color:var(--cyan)">${speedup}√ó</div><div style="font-size:0.62rem;color:var(--text-dim)">vs single model</div></div>`;
            html += `<div style="text-align:center"><div style="font-size:1.6rem;font-weight:800;color:var(--orange)">${totalTokensEst}</div><div style="font-size:0.62rem;color:var(--text-dim)">total tokens</div></div>`;
            html += `</div>`;
            html += `<div style="font-size:0.6rem;color:var(--text-dim);margin-top:6px">${validResults.length} models √ó ~${Math.round(totalTokensEst/validResults.length)} tok each in ${elapsedSec.toFixed(1)}s wall-clock (parallel fan-out)</div>`;
            html += `</div>`;

            // Consensus header
            html += `<div style="text-align:center;padding:16px 0 8px">`;
            html += `<div style="font-size:0.7rem;color:var(--accent);font-weight:700;letter-spacing:1px;margin-bottom:8px">‚°™ CRDT MERGE RESULT</div>`;
            html += `<div id="crdt-consensus-char" style="font-size:5rem;line-height:1;opacity:0;transition:opacity 1s ease-in,transform 0.6s ease-out;transform:scale(0.5)">${consensusBraille}</div>`;
            html += `<div style="font-size:0.75rem;color:var(--text-dim);margin-top:6px">${totalLatency}ms ¬∑ ${validResults.length}/${selectedModels.length} models ¬∑ ${totalInputChars} chars ‚Üí 8 bits</div>`;
            html += `</div>`;

            // Per-model vectors with color
            html += `<div style="padding:10px 0;display:flex;flex-wrap:wrap;gap:6px;justify-content:center">`;
            validResults.forEach((r, i) => {
                const m = selectedModels.find(sm => sm.name === r.model) || selectedModels[i];
                const brChar = crdt.vectorToBraille(vectors[i]);
                html += `<div style="font-size:0.7rem;padding:4px 10px;border-radius:6px;border:1px solid ${m.color}44;background:${m.color}11">`;
                html += `<span style="color:${m.color};font-weight:600">${r.model}</span> `;
                html += `<span style="font-size:1.3rem">${brChar}</span>`;
                html += `</div>`;
            });
            html += `</div>`;

            // 8-Dimension bar chart
            html += `<div style="padding:10px 0"><div style="font-size:0.75rem;font-weight:700;color:var(--accent);margin-bottom:6px">Semantic Dimensions (G-Counter)</div>`;
            const gv = Array.from(gCounter);
            for (let d = 0; d < 8; d++) {
                const pct = (gv[d] * 100).toFixed(0);
                const barW = Math.max(2, gv[d] * 100);
                html += `<div style="display:flex;align-items:center;margin:2px 0;font-size:0.68rem">`;
                html += `<span style="width:82px;color:${DIM_COLORS[d]};text-align:right;padding-right:6px">d${d} ${DIM_LABELS[d]}</span>`;
                html += `<div style="flex:1;height:12px;background:var(--bg-code);border-radius:3px;overflow:hidden">`;
                html += `<div class="crdt-bar" data-target="${barW}" style="width:0%;height:100%;background:${DIM_COLORS[d]};border-radius:3px;transition:width 0.8s ease-out"></div>`;
                html += `</div>`;
                html += `<span style="width:32px;text-align:right;color:var(--text-dim);padding-left:4px">${pct}%</span>`;
                html += `</div>`;
            }
            html += `</div>`;

            // Majority vote + agreement
            html += `<div style="padding:8px 0;border-top:1px solid var(--border);display:flex;gap:16px;flex-wrap:wrap">`;
            html += `<div><span style="font-size:0.7rem;font-weight:700;color:var(--orange)">Majority Vote: </span><span style="font-size:1.4rem">${binaryBraille}</span> <span style="font-size:0.65rem;color:var(--text-dim)">[${Array.from(majorityVote).join(',')}]</span></div>`;
            html += `<div style="font-size:0.7rem;color:var(--text-dim)">Consensus: <strong style="color:var(--text)">${agreement.consensusStrength}</strong> ¬∑ Cosine: ${agreement.avgCosine} ¬∑ Hamming: ${agreement.avgHamming}</div>`;
            html += `</div>`;

            // OR-Set concepts
            if (orSet.length > 0) {
                html += `<div style="padding:8px 0;border-top:1px solid var(--border)">`;
                html += `<div style="font-size:0.72rem;font-weight:700;color:var(--purple);margin-bottom:4px">OR-Set Concepts</div>`;
                html += `<div style="display:flex;flex-wrap:wrap;gap:3px">`;
                for (const c of orSet.slice(0, 15)) {
                    const op = Math.min(1, 0.3 + c.sources.size * 0.2);
                    html += `<span style="font-size:0.65rem;background:rgba(168,130,255,${op});padding:2px 7px;border-radius:10px;color:var(--text)">${c.text} <span style="opacity:0.6">√ó${c.sources.size}</span></span>`;
                }
                html += `</div></div>`;
            }

            // LWW best response
            html += `<div style="padding:8px 0;border-top:1px solid var(--border)">`;
            const lwwModel = selectedModels.find(m => m.name === lww.bestResult.model);
            const lwwColor = lwwModel?.color || 'var(--text)';
            html += `<div style="font-size:0.72rem;font-weight:700;color:var(--yellow)">LWW-Register: <span style="color:${lwwColor}">${lww.bestResult.model}</span> <span style="color:var(--text-dim);font-weight:400">(${lww.similarity.toFixed(4)} cosine)</span></div>`;
            html += `</div>`;

            // Inject into merge area and animate
            const mergeArea = document.getElementById('crdt-merge-area');
            mergeArea.innerHTML = html;
            mergeArea.style.opacity = '1';

            // Play merge chord + animate consensus character
            if (ttsEnabled) tts.playMergeChord(gCounter, 2000);
            await new Promise(r => setTimeout(r, 100));
            const charEl = document.getElementById('crdt-consensus-char');
            if (charEl) { charEl.style.opacity = '1'; charEl.style.transform = 'scale(1)'; }

            // Animate bars growing
            await new Promise(r => setTimeout(r, 200));
            document.querySelectorAll('.crdt-bar').forEach(bar => {
                bar.style.width = bar.dataset.target + '%';
            });

            crdtStatus.textContent = '‚óè done';
            crdtStatus.style.color = 'var(--green)';

        } catch (e) {
            crdtOutput.innerHTML += `<div class="sal-msg sal" style="color:var(--red)"><span class="sal-name">‚°™ CRDT</span>‚†ª ${e.message}</div>`;
            crdtStatus.textContent = '‚óè error';
            crdtStatus.style.color = 'var(--red)';
        } finally {
            crdtRunBtn.disabled = false;
            crdtInput.disabled = false;
        }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // ¬ß9  BATCH DISTILLATION ‚Äî N rounds √ó M models
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    const crdtBatchBtn = document.getElementById('crdt-batch');
    const crdtRoundsSelect = document.getElementById('crdt-rounds');
    crdtBatchBtn.addEventListener('click', runBatchDistillation);

    async function runBatchDistillation() {
        const query = crdtInput.value.trim();
        if (!query) return;

        const apiKey = sessionStorage.getItem('sal_api_key');
        if (!apiKey) {
            crdtOutput.innerHTML = '<div class="sal-msg sal"><span class="sal-name">‚°™ CRDT</span>‚†ª No API key.</div>';
            return;
        }

        const checked = document.querySelectorAll('.crdt-model:checked');
        if (checked.length === 0) {
            crdtOutput.innerHTML = '<div class="sal-msg sal"><span class="sal-name">‚°™ CRDT</span>‚†ª Select at least one model.</div>';
            return;
        }
        const selectedModels = Array.from(checked).map(cb => BrailleLang.FRONTIER_MODELS.find(m => m.id === cb.value)).filter(Boolean);
        const rounds = parseInt(crdtRoundsSelect.value);

        crdtRunBtn.disabled = true;
        crdtBatchBtn.disabled = true;
        crdtInput.disabled = true;
        crdtStatus.textContent = '‚óè batch mode...';
        crdtStatus.style.color = 'var(--accent)';

        // Build batch layout
        let html = '<div style="padding:8px">';
        html += `<div style="text-align:center;margin-bottom:10px">`;
        html += `<div style="font-size:0.65rem;color:var(--accent);font-weight:700;letter-spacing:2px">‚£ø BATCH DISTILLATION</div>`;
        html += `<div style="font-size:0.7rem;color:var(--text-dim)">${rounds} rounds √ó ${selectedModels.length} models = ${rounds * selectedModels.length} parallel streams</div>`;
        html += `<div id="batch-braille-seq" style="font-size:2.5rem;margin:8px 0;min-height:3rem;letter-spacing:4px"></div>`;
        html += `<div id="batch-progress" style="font-size:0.7rem;color:var(--text-dim)"></div>`;
        html += `</div>`;
        html += `<div id="batch-rounds"></div>`;
        html += `<div id="batch-final" style="opacity:0;transition:opacity 0.8s"></div>`;
        html += '</div>';
        crdtOutput.innerHTML = html;

        const crdt = new BrailleLang.BrailleCRDT({ apiKey, models: selectedModels });
        const brailleSeqEl = document.getElementById('batch-braille-seq');
        const batchRoundsEl = document.getElementById('batch-rounds');
        const batchProgressEl = document.getElementById('batch-progress');

        try {
            const report = await crdt.batchDistill(query, {
                rounds,
                models: selectedModels,
                onRoundStart: (round, total, facet) => {
                    crdtStatus.textContent = `‚óè round ${round + 1}/${total}`;
                    batchProgressEl.textContent = `Round ${round + 1}/${total}: ${facet.split(':')[0]}...`;
                    // Add round container
                    const div = document.createElement('div');
                    div.id = `batch-round-${round}`;
                    div.style.cssText = 'margin-bottom:8px;border:1px solid var(--border);border-radius:6px;overflow:hidden;opacity:0.5;transition:opacity 0.3s';
                    div.innerHTML = `<div style="padding:4px 8px;background:var(--bg-code);font-size:0.62rem;color:var(--text-dim);display:flex;justify-content:space-between"><span>R${round + 1}: ${facet.split(':')[0]}</span><span id="batch-round-status-${round}">‚†† streaming ${selectedModels.length} models...</span></div>`;
                    // Mini grid for this round
                    const cols = Math.min(selectedModels.length, 5);
                    let grid = `<div style="display:grid;grid-template-columns:repeat(${cols}, 1fr);gap:3px;padding:4px">`;
                    selectedModels.forEach((m, i) => {
                        grid += `<div id="batch-r${round}-m${i}" style="font-size:0.55rem;color:${m.color};padding:2px 4px;max-height:60px;overflow:hidden;white-space:nowrap;text-overflow:ellipsis"></div>`;
                    });
                    grid += '</div>';
                    div.innerHTML += grid;
                    batchRoundsEl.appendChild(div);
                },
                onToken: (round, i, delta, full) => {
                    const el = document.getElementById(`batch-r${round}-m${i}`);
                    if (el) el.textContent = full.slice(-80);
                },
                onModelDone: (round, i, result) => {
                    const el = document.getElementById(`batch-r${round}-m${i}`);
                    if (el) el.style.opacity = '1';
                },
                onModelError: (round, i, result) => {
                    const el = document.getElementById(`batch-r${round}-m${i}`);
                    if (el) { el.textContent = '‚†ª'; el.style.color = 'var(--red)'; }
                },
                onRoundDone: (round, data) => {
                    const roundEl = document.getElementById(`batch-round-${round}`);
                    if (roundEl) roundEl.style.opacity = '1';
                    const statusEl = document.getElementById(`batch-round-status-${round}`);
                    if (statusEl) statusEl.textContent = `‚úì ${data.modelsResponded} models ¬∑ ${data.totalChars} chars ‚Üí ${data.braille}`;
                    brailleSeqEl.textContent = (brailleSeqEl.textContent || '') + data.braille;
                    // Play this round's consensus as a tone
                    if (ttsEnabled) tts.playVector(data.gCounter, 180);
                },
            });

            // Final report
            batchProgressEl.textContent = 'Merging all rounds...';
            await new Promise(r => setTimeout(r, 500));

            const aggTpm = selectedModels.reduce((s, m) => s + (m.tpm || 30000), 0);
            const aggTpmStr = aggTpm >= 1000000 ? (aggTpm / 1000000).toFixed(1) + 'M' : (aggTpm / 1000).toFixed(0) + 'K';
            const speedup = (aggTpm / Math.max(...selectedModels.map(m => m.tpm || 30000))).toFixed(1);

            let finalHtml = '';
            finalHtml += `<div style="text-align:center;padding:16px 0 8px;border-top:2px solid var(--accent)">`;
            finalHtml += `<div style="font-size:0.65rem;color:var(--accent);font-weight:700;letter-spacing:2px;margin-bottom:6px">‚£ø BATCH RESULT</div>`;
            finalHtml += `<div style="font-size:3rem;letter-spacing:6px;margin:8px 0">${report.brailleSequence}</div>`;
            finalHtml += `<div style="font-size:0.7rem;color:var(--text-dim)">${report.totalRounds} rounds ¬∑ ${report.brailleSequence.length} braille chars ¬∑ super-consensus: <span style="font-size:1.8rem">${report.superConsensus}</span></div>`;
            finalHtml += `</div>`;

            // Throughput banner
            finalHtml += `<div style="display:flex;justify-content:center;gap:20px;flex-wrap:wrap;padding:12px 0;border-bottom:1px solid var(--border)">`;
            finalHtml += `<div style="text-align:center"><div style="font-size:1.8rem;font-weight:800;color:var(--text)">${report.tokPerSec}</div><div style="font-size:0.6rem;color:var(--text-dim)">tok/sec</div></div>`;
            finalHtml += `<div style="text-align:center"><div style="font-size:1.8rem;font-weight:800;color:var(--accent)">${aggTpmStr}</div><div style="font-size:0.6rem;color:var(--text-dim)">aggregate TPM</div></div>`;
            finalHtml += `<div style="text-align:center"><div style="font-size:1.8rem;font-weight:800;color:var(--cyan)">${speedup}√ó</div><div style="font-size:0.6rem;color:var(--text-dim)">vs single model</div></div>`;
            finalHtml += `<div style="text-align:center"><div style="font-size:1.8rem;font-weight:800;color:var(--orange)">${report.totalTokens}</div><div style="font-size:0.6rem;color:var(--text-dim)">total tokens</div></div>`;
            finalHtml += `<div style="text-align:center"><div style="font-size:1.8rem;font-weight:800;color:var(--purple)">${report.totalModelResponses}</div><div style="font-size:0.6rem;color:var(--text-dim)">model responses</div></div>`;
            finalHtml += `</div>`;

            // Stats line
            finalHtml += `<div style="text-align:center;padding:8px 0;font-size:0.62rem;color:var(--text-dim)">`;
            finalHtml += `${report.totalRounds} rounds √ó ${selectedModels.length} models = ${report.totalModelResponses} parallel streams in ${(report.totalMs / 1000).toFixed(1)}s wall-clock`;
            finalHtml += `<br>${report.totalChars} chars ‚Üí ${report.brailleSequence.length} braille chars (${Math.round(report.totalChars / report.brailleSequence.length)}:1 compression per char)`;
            finalHtml += `</div>`;

            const finalEl = document.getElementById('batch-final');
            finalEl.innerHTML = finalHtml;
            finalEl.style.opacity = '1';
            batchProgressEl.textContent = `‚úì Complete ‚Äî ${report.totalMs}ms`;

            // Play the super-consensus as a dramatic merge chord
            if (ttsEnabled) {
                const superVec = new Float64Array(report.superVector);
                tts.playMergeChord(superVec, 2500);
            }

            crdtStatus.textContent = '‚óè done';
            crdtStatus.style.color = 'var(--green)';

        } catch (e) {
            crdtOutput.innerHTML += `<div class="sal-msg sal" style="color:var(--red)"><span class="sal-name">‚°™ CRDT</span>‚†ª ${e.message}</div>`;
            crdtStatus.textContent = '‚óè error';
            crdtStatus.style.color = 'var(--red)';
        } finally {
            crdtRunBtn.disabled = false;
            crdtBatchBtn.disabled = false;
            crdtInput.disabled = false;
        }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // ¬ß10  HONESTY PROBE ‚Äî Calibrate model trustworthiness
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    const crdtProbeBtn = document.getElementById('crdt-probe');
    let lastHonestyResults = null; // Persists across distillation runs

    crdtProbeBtn.addEventListener('click', runHonestyProbe);

    async function runHonestyProbe() {
        const apiKey = sessionStorage.getItem('sal_api_key');
        if (!apiKey) {
            crdtOutput.innerHTML = '<div class="sal-msg sal"><span class="sal-name">‚°™ CRDT</span>‚†ª No API key. Enter your OpenRouter key in SAL Chat first.</div>';
            return;
        }

        const checked = document.querySelectorAll('.crdt-model:checked');
        if (checked.length === 0) {
            crdtOutput.innerHTML = '<div class="sal-msg sal"><span class="sal-name">‚°™ CRDT</span>‚†ª Select at least one model.</div>';
            return;
        }
        const selectedModels = Array.from(checked).map(cb => BrailleLang.FRONTIER_MODELS.find(m => m.id === cb.value)).filter(Boolean);

        crdtRunBtn.disabled = true;
        crdtBatchBtn.disabled = true;
        crdtProbeBtn.disabled = true;
        crdtInput.disabled = true;
        crdtStatus.textContent = '‚óè probing honesty...';
        crdtStatus.style.color = 'var(--cyan)';

        // Build probe layout
        let html = '<div style="padding:12px">';
        html += '<div style="text-align:center;margin-bottom:12px">';
        html += '<div style="font-size:0.72rem;color:var(--cyan);font-weight:700;letter-spacing:2px">‚öñ HONESTY PROBE</div>';
        html += '<div style="font-size:0.65rem;color:var(--text-dim)">Testing each model with verifiable braille math questions</div>';
        html += '</div>';
        html += '<div id="probe-grid" style="display:grid;grid-template-columns:repeat(auto-fill, minmax(180px, 1fr));gap:8px">';
        selectedModels.forEach((m, i) => {
            html += `<div id="probe-card-${i}" style="border:1px solid ${m.color}33;border-radius:8px;padding:10px;opacity:0.5;transition:all 0.3s">`;
            html += `<div style="font-size:0.68rem;font-weight:700;color:${m.color};margin-bottom:6px">${m.name}</div>`;
            html += `<div id="probe-status-${i}" style="font-size:0.6rem;color:var(--text-dim)">‚†† waiting...</div>`;
            html += `<div id="probe-score-${i}" style="font-size:1.8rem;font-weight:900;margin:6px 0;opacity:0;transition:opacity 0.5s"></div>`;
            html += `<div id="probe-detail-${i}" style="font-size:0.55rem;color:var(--text-dim)"></div>`;
            html += `<div id="probe-weight-${i}" style="font-size:0.55rem;margin-top:4px"></div>`;
            html += '</div>';
        });
        html += '</div>';
        html += '<div id="probe-summary" style="text-align:center;margin-top:12px;opacity:0;transition:opacity 0.5s"></div>';
        html += '</div>';
        crdtOutput.innerHTML = html;

        const crdt = new BrailleLang.BrailleCRDT({ apiKey, models: selectedModels });
        const PROBE_TYPES = BrailleLang.BrailleCRDT.PROBE_TYPE_NAMES;

        try {
            const { scores, adjustedModels, history } = await crdt.honestyProbe({
                models: selectedModels,
                onProbeResult: (i, name, score, details, perTypeScores) => {
                    const card = document.getElementById(`probe-card-${i}`);
                    const statusEl = document.getElementById(`probe-status-${i}`);
                    const scoreEl = document.getElementById(`probe-score-${i}`);
                    const detailEl = document.getElementById(`probe-detail-${i}`);
                    const weightEl = document.getElementById(`probe-weight-${i}`);

                    if (card) card.style.opacity = '1';

                    // Color-code score
                    let scoreColor = 'var(--red)';
                    let badge = '‚†ª HALLUCINATING';
                    if (score >= 0.8) { scoreColor = 'var(--green)'; badge = '‚úì GROUNDED'; }
                    else if (score >= 0.5) { scoreColor = 'var(--yellow)'; badge = '‚ö† PARTIAL'; }
                    else if (score >= 0.3) { scoreColor = 'var(--orange)'; badge = '‚ö† UNRELIABLE'; }

                    if (scoreEl) {
                        scoreEl.textContent = (score * 100).toFixed(0) + '%';
                        scoreEl.style.color = scoreColor;
                        scoreEl.style.opacity = '1';
                    }
                    if (statusEl) {
                        statusEl.innerHTML = `<span style="color:${scoreColor};font-weight:700">${badge}</span>`;
                    }
                    if (detailEl) {
                        // Per-probe-type breakdown with mini bars
                        let barHtml = '<div style="display:grid;grid-template-columns:70px 1fr 40px;gap:2px;margin-top:4px">';
                        details.forEach(d => {
                            const pct = (d.score * 100).toFixed(0);
                            const barColor = d.score >= 0.8 ? 'var(--green)' : d.score >= 0.4 ? 'var(--yellow)' : 'var(--red)';
                            barHtml += `<div>${PROBE_TYPES[d.probeType]}</div>`;
                            barHtml += `<div style="background:var(--bg-code);border-radius:3px;overflow:hidden;height:10px;margin-top:2px"><div style="width:${pct}%;height:100%;background:${barColor};transition:width 0.5s"></div></div>`;
                            barHtml += `<div style="text-align:right;color:${barColor}">${pct}%</div>`;
                        });
                        barHtml += '</div>';
                        // Show answers
                        details.forEach(d => {
                            if (d.answer) barHtml += `<div style="margin-top:2px;color:var(--text-dim);font-style:italic;max-height:18px;overflow:hidden;font-size:0.5rem">${PROBE_TYPES[d.probeType]}: "${d.answer}"</div>`;
                            if (d.error) barHtml += `<div style="color:var(--red);font-size:0.5rem">${PROBE_TYPES[d.probeType]}: ${d.error}</div>`;
                        });
                        detailEl.innerHTML = barHtml;
                    }

                    // Play honesty tone ‚Äî the perTypeScores become the 8D vector
                    if (ttsEnabled) {
                        const vec = new Float64Array(8);
                        vec[0] = perTypeScores[0]; // bits ‚Üí existence
                        vec[2] = perTypeScores[1]; // freqs ‚Üí temporal
                        vec[3] = perTypeScores[2]; // vector ‚Üí spatial
                        vec[5] = perTypeScores[3]; // dots ‚Üí cognitive
                        vec[7] = score; // composite ‚Üí transcendent
                        tts.playVector(vec, 120);
                    }
                },
            });

            // Store for subsequent distillation
            lastHonestyResults = { scores, adjustedModels };

            // Summary
            const avgHonesty = scores.reduce((s, r) => s + r.score, 0) / scores.length;
            const grounded = scores.filter(s => s.score >= 0.8).length;
            const partial = scores.filter(s => s.score >= 0.3 && s.score < 0.8).length;
            const hallucinating = scores.filter(s => s.score < 0.3).length;

            // Count total CRDT-merged probe runs
            const historyRuns = Object.values(history);
            const maxRuns = historyRuns.length > 0 ? Math.max(...historyRuns.map(h => h.probeRuns)) : 1;

            const summaryEl = document.getElementById('probe-summary');
            if (summaryEl) {
                let summaryHtml = `<div style="font-size:0.72rem;font-weight:700;color:var(--cyan)">‚öñ CRDT Calibration Complete</div>`;
                summaryHtml += `<div style="font-size:0.6rem;color:var(--text-dim);margin-top:2px">4 probe types √ó ${selectedModels.length} models = ${4 * selectedModels.length} verifiable questions</div>`;
                summaryHtml += `<div style="font-size:0.65rem;color:var(--text-dim);margin-top:4px">`;
                const hColor = avgHonesty >= 0.7 ? 'var(--green)' : avgHonesty >= 0.4 ? 'var(--yellow)' : 'var(--red)';
                summaryHtml += `Avg honesty: <span style="color:${hColor};font-weight:700">${(avgHonesty * 100).toFixed(0)}%</span>`;
                summaryHtml += ` ¬∑ <span style="color:var(--green)">${grounded} grounded</span>`;
                summaryHtml += ` ¬∑ <span style="color:var(--yellow)">${partial} partial</span>`;
                summaryHtml += ` ¬∑ <span style="color:var(--red)">${hallucinating} hallucinating</span>`;
                summaryHtml += `</div>`;
                summaryHtml += `<div style="font-size:0.58rem;color:var(--accent);margin-top:6px;font-weight:600">`;
                summaryHtml += `CRDT history: ${maxRuns} run${maxRuns > 1 ? 's' : ''} merged ¬∑ Weights adjusted ¬∑ System prompts now include calibration leaderboard`;
                summaryHtml += `</div>`;

                // Show weight changes
                summaryHtml += `<div style="font-size:0.55rem;color:var(--text-dim);margin-top:8px;display:flex;flex-wrap:wrap;gap:6px;justify-content:center">`;
                adjustedModels.forEach(m => {
                    const change = ((m.weight / m.originalWeight - 1) * 100).toFixed(0);
                    const arrow = parseInt(change) >= 0 ? '‚Üë' : '‚Üì';
                    const color = m.honestyScore >= 0.8 ? 'var(--green)' : m.honestyScore >= 0.3 ? 'var(--yellow)' : 'var(--red)';
                    summaryHtml += `<span style="color:${color}">${m.name}: ${m.weight.toFixed(2)} (${arrow}${Math.abs(parseInt(change))}%)</span>`;
                });
                summaryHtml += `</div>`;

                summaryEl.innerHTML = summaryHtml;
                summaryEl.style.opacity = '1';
            }

            // Update per-card weight display + history run count
            adjustedModels.forEach((m, i) => {
                const weightEl = document.getElementById(`probe-weight-${i}`);
                if (weightEl) {
                    const h = history[m.id];
                    const runs = h ? h.probeRuns : 1;
                    const change = ((m.weight / m.originalWeight - 1) * 100).toFixed(0);
                    const color = parseInt(change) >= 0 ? 'var(--green)' : 'var(--red)';
                    weightEl.innerHTML = `weight: ${m.originalWeight.toFixed(2)} ‚Üí <span style="color:${color};font-weight:700">${m.weight.toFixed(2)}</span> ¬∑ <span style="color:var(--text-dim)">${runs} run${runs > 1 ? 's' : ''} merged</span>`;
                }
            });

            // Play summary chord ‚Äî sparse, warm frequencies only
            if (ttsEnabled) {
                const summaryVec = new Float64Array(8);
                summaryVec[0] = avgHonesty;       // 200 Hz ‚Äî warm base
                summaryVec[2] = avgHonesty * 0.7;  // 600 Hz ‚Äî mid
                summaryVec[5] = avgHonesty * 0.5;  // 2400 Hz ‚Äî cognitive
                tts.playMergeChord(summaryVec, 1200);
            }

            crdtStatus.textContent = '‚óè calibrated';
            crdtStatus.style.color = 'var(--cyan)';

        } catch (e) {
            crdtOutput.innerHTML += `<div class="sal-msg sal" style="color:var(--red)"><span class="sal-name">‚°™ CRDT</span>‚†ª ${e.message}</div>`;
            crdtStatus.textContent = '‚óè error';
            crdtStatus.style.color = 'var(--red)';
        } finally {
            crdtRunBtn.disabled = false;
            crdtBatchBtn.disabled = false;
            crdtProbeBtn.disabled = false;
            crdtInput.disabled = false;
        }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // ¬ß11  AUTO-PROBE ‚Äî Overnight unattended honesty calibration
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    const crdtAutoProbeBtn = document.getElementById('crdt-auto-probe');
    let autoProbeInterval = null;
    let autoProbeRun = 0;
    const AUTO_PROBE_INTERVAL_MS = 2 * 60 * 1000; // 2 minutes
    const AUTO_PROBE_MAX_RUNS = 50;

    crdtAutoProbeBtn.addEventListener('click', toggleAutoProbe);

    function toggleAutoProbe() {
        if (autoProbeInterval) {
            // Stop
            clearInterval(autoProbeInterval);
            autoProbeInterval = null;
            crdtAutoProbeBtn.textContent = '‚ü≥ AUTO';
            crdtAutoProbeBtn.style.background = '#1a1a2e';
            crdtAutoProbeBtn.style.color = 'var(--cyan)';
            crdtStatus.textContent = `‚óè auto-probe stopped (${autoProbeRun} runs completed)`;
            crdtStatus.style.color = 'var(--text-dim)';
            return;
        }

        const apiKey = sessionStorage.getItem('sal_api_key');
        if (!apiKey) {
            crdtOutput.innerHTML = '<div class="sal-msg sal"><span class="sal-name">‚°™ CRDT</span>‚†ª No API key.</div>';
            return;
        }

        const checked = document.querySelectorAll('.crdt-model:checked');
        if (checked.length === 0) {
            crdtOutput.innerHTML = '<div class="sal-msg sal"><span class="sal-name">‚°™ CRDT</span>‚†ª Select at least one model.</div>';
            return;
        }

        // Start auto-probe
        autoProbeRun = 0;
        const startTime = Date.now();
        crdtAutoProbeBtn.textContent = '‚ñ† STOP';
        crdtAutoProbeBtn.style.background = 'var(--red)';
        crdtAutoProbeBtn.style.color = '#fff';

        // Show auto-probe dashboard
        const costPerRun = checked.length * 4 * 0.001; // ~$0.001 per API call, 4 probes per model
        let dashHtml = '<div style="padding:12px;text-align:center">';
        dashHtml += '<div style="font-size:0.72rem;color:var(--cyan);font-weight:700;letter-spacing:2px">‚ü≥ AUTO-PROBE RUNNING</div>';
        dashHtml += '<div style="font-size:0.6rem;color:var(--text-dim);margin-top:4px">Probing every 2 min ¬∑ Max 50 runs ¬∑ ~$' + (costPerRun * AUTO_PROBE_MAX_RUNS).toFixed(2) + ' total</div>';
        dashHtml += '<div style="margin:16px 0">';
        dashHtml += '<div id="auto-probe-count" style="font-size:2.5rem;font-weight:900;color:var(--cyan)">0</div>';
        dashHtml += '<div style="font-size:0.6rem;color:var(--text-dim)">runs completed</div>';
        dashHtml += '</div>';
        dashHtml += '<div style="display:flex;gap:20px;justify-content:center;font-size:0.6rem;color:var(--text-dim)">';
        dashHtml += '<div>‚è± <span id="auto-probe-elapsed">0:00</span></div>';
        dashHtml += '<div>üí∞ ~$<span id="auto-probe-cost">0.00</span></div>';
        dashHtml += '<div>‚ü≥ next in <span id="auto-probe-next">2:00</span></div>';
        dashHtml += '</div>';
        dashHtml += '<div id="auto-probe-log" style="margin-top:12px;font-size:0.52rem;color:var(--text-dim);max-height:200px;overflow-y:auto;text-align:left;padding:0 20px"></div>';
        dashHtml += '</div>';
        crdtOutput.innerHTML = dashHtml;

        // Countdown timer
        let countdownSec = 0;
        const countdownInterval = setInterval(() => {
            if (!autoProbeInterval) { clearInterval(countdownInterval); return; }
            countdownSec++;
            const nextSec = Math.max(0, 120 - (countdownSec % 120));
            const nextEl = document.getElementById('auto-probe-next');
            if (nextEl) nextEl.textContent = Math.floor(nextSec / 60) + ':' + String(nextSec % 60).padStart(2, '0');
            const elapsedEl = document.getElementById('auto-probe-elapsed');
            if (elapsedEl) {
                const totalSec = Math.floor((Date.now() - startTime) / 1000);
                const h = Math.floor(totalSec / 3600);
                const m = Math.floor((totalSec % 3600) / 60);
                const s = totalSec % 60;
                elapsedEl.textContent = h > 0 ? `${h}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}` : `${m}:${String(s).padStart(2,'0')}`;
            }
        }, 1000);

        async function runOneAutoProbe() {
            if (autoProbeRun >= AUTO_PROBE_MAX_RUNS) {
                clearInterval(autoProbeInterval);
                autoProbeInterval = null;
                clearInterval(countdownInterval);
                crdtAutoProbeBtn.textContent = '‚ü≥ AUTO';
                crdtAutoProbeBtn.style.background = '#1a1a2e';
                crdtAutoProbeBtn.style.color = 'var(--cyan)';
                crdtStatus.textContent = `‚óè auto-probe complete (${autoProbeRun} runs)`;
                crdtStatus.style.color = 'var(--green)';
                const logEl = document.getElementById('auto-probe-log');
                if (logEl) logEl.innerHTML += `<div style="color:var(--green);font-weight:700">‚úì All ${AUTO_PROBE_MAX_RUNS} runs complete. CRDT history fully converged.</div>`;
                return;
            }

            const selectedModels = Array.from(document.querySelectorAll('.crdt-model:checked'))
                .map(cb => BrailleLang.FRONTIER_MODELS.find(m => m.id === cb.value)).filter(Boolean);

            const crdt = new BrailleLang.BrailleCRDT({ apiKey, models: selectedModels });
            autoProbeRun++;

            crdtStatus.textContent = `‚óè auto-probe run ${autoProbeRun}/${AUTO_PROBE_MAX_RUNS}...`;
            crdtStatus.style.color = 'var(--cyan)';

            const countEl = document.getElementById('auto-probe-count');
            if (countEl) countEl.textContent = autoProbeRun;
            const costEl = document.getElementById('auto-probe-cost');
            if (costEl) costEl.textContent = (autoProbeRun * costPerRun).toFixed(2);

            try {
                const { scores, history } = await crdt.honestyProbe({ models: selectedModels });

                const logEl = document.getElementById('auto-probe-log');
                if (logEl) {
                    const avg = scores.reduce((s, r) => s + r.score, 0) / scores.length;
                    const ts = new Date().toLocaleTimeString();
                    const top = scores.sort((a, b) => b.score - a.score)[0];
                    const maxRuns = Math.max(...Object.values(history).map(h => h.probeRuns));
                    logEl.innerHTML = `<div>[${ts}] Run ${autoProbeRun}: avg ${(avg * 100).toFixed(0)}% ¬∑ top: ${top.model} (${(top.score * 100).toFixed(0)}%) ¬∑ ${maxRuns} total merged</div>` + logEl.innerHTML;
                }

                // Store for distillation
                lastHonestyResults = { scores, adjustedModels: selectedModels.map((m, i) => {
                    const h = history[m.id];
                    const hs = h ? h.composite : scores[i].score;
                    return { ...m, originalWeight: m.weight, honestyScore: hs, weight: Math.max(0.1, m.weight * (0.3 + 0.7 * hs)) };
                })};

                crdtStatus.textContent = `‚óè auto-probe: ${autoProbeRun}/${AUTO_PROBE_MAX_RUNS} done ¬∑ next in 2 min`;
                crdtStatus.style.color = 'var(--cyan)';
            } catch (e) {
                const logEl = document.getElementById('auto-probe-log');
                if (logEl) logEl.innerHTML = `<div style="color:var(--red)">[${new Date().toLocaleTimeString()}] Run ${autoProbeRun}: ‚†ª ${e.message}</div>` + logEl.innerHTML;
            }
        }

        // Run first probe immediately, then every 2 minutes
        runOneAutoProbe();
        autoProbeInterval = setInterval(runOneAutoProbe, AUTO_PROBE_INTERVAL_MS);
    }

});
</script>
</body>
</html>
